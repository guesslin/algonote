<html lang="zh-TW"><head><meta charset="UTF-8" /><link rel="stylesheet" href="style.css" />
<title>演算法筆記 - Algorithm Design</title></head><body>
<div class="a"><div class="h">
<p class="b">Incremental Method</p>
<p class="w">不積跬步，無以至千里。不積小流，無以成江海。《荀子》</p>
</div><div class="c">
<p class="t">Incremental Method</p>
<p>「遞增法」是符合電腦運作特性的方法。電腦執行程式，一次只做一個動作，完成了一件事才做下一件事。當一個問題太大太多時，化整為零、一個一個解決吧！</p>
<p>合抱之木，生於毫末；九層之臺，起於累土；千里之行，始於足下。謹以此句與大家共勉。</p>
<p class="t">範例：加總數字</p>
<p>無論電腦再怎麼強，還是得一個一個累加數字。</p>
<img src="Incremental1.png">
<textarea>
void summation()
{
	int array[5] = {3, 6, 9, -8, 1};

	int sum = 0;
	for (int i=0; i<5; i++)
		sum += array[i];

	cout << "總和是" << sum;
}
</textarea>
<textarea>
int summation(int array[], int n)
{
	int sum = 0;
	for (int i=0; i<n; i++)
		sum += array[i];
	return sum;
}
</textarea>
<p class="t">範例：複製字串</p>
<p>無論電腦再怎麼強，還是得逐字複製。</p>
<img src="Incremental2.png">
<textarea>
void copy()
{
	char s[15] = "incremental";
	char t[15];

	int i;
	for (i=0; s[i] != '\0'; ++i)
		t[i] = s[i];
	t[i] = '\0';

	cout << "原本字串" << s;
	cout << "複製之後的字串" << t;
}
</textarea>
<textarea>
void copy(char* s, char* t)
{
	int i;
	for (i=0; s[i]; ++i)
		t[i] = s[i];
	t[i] = '\0';
}
</textarea>
<p class="t">範例：選擇排序法（Selection Sort）</p>
<p>找到第一小的數字，放在第一個位置；再找到第二小的數字，放在第二個位置。一次找一個數字，如此下去就會把所有數值按照順序排好了。</p>
<img src="Incremental3.png">
<textarea>
void selection_sort()
{
	int array[5] = {3, 6, 9, -8, 1};

	for (int i=0; i<5; ++i)
	{
		// 從尚未排序的數字當中，找到第i小的數值。
		int min_index = i;
		for (int j=i+1; j<5; ++j)
			if (array[j] < array[min_index])
				min_index = j;

		// 把第i小的數值，放在第i個位置。
		swap(array[i], array[min_index]);
	}

	// 印出排序結果。
	for (int i=0; i<5; ++i)
		cout << array[i];
}
</textarea>
<textarea>
void selection_sort(int array[], int n)
{
	for (int i=0; i<n; ++i)
	{
		// 從尚未排序的數字當中，找到第i小的數值。
		int min_index = i;
		for (int j=i+1; j<n; ++j)
			if (array[j] < array[min_index])
				min_index = j;

		// 把第i小的數值，放在第i個位置。
		swap(array[i], array[min_index]);
	}
}
</textarea>
<p class="t">範例：印出直角三角形</p>
<p>多字成行，多行成直角三角形。由細微的東西開始，一件一件組起來。</p>
<img src="Incremental4.png">
<textarea>
// 多字成行
void print_line(int n)	// n 是一行的長度
{
	for (int i=1; i<=n; i++) cout << '@';
	cout << '\n';
}

// 多行成直角三角形
void print_triangle(int n)	// n 是行數
{
	for (int i=n; i>=1; i--) print_line(i);
}
</textarea>
<p class="e">UVa 488 10038 10107 10370</p>
<p class="t">範例：人潮最多的時段（Interval Partitioning Problem）</p>
<p>一群訪客參加宴會，我們詢問到每一位訪客的進場時刻與出場時刻，請問宴會現場擠進最多人的時段。</p>
<p>換個角度想，想像會場門口裝著一支監視器。有訪客進入，會場就多一人；有訪客離開，會場就少一人。如此就很容易統計會場人數。遞增的標的是時刻，而不是訪客。</p>
<p>【註：這個技巧在中文網路上暱稱為「離散化」。】</p>
<img src="Incremental5.png">
<textarea>
struct Guest {int arrival, leave;} g[10];

bool cmp(const int& i, const int& j)
{
	return abs(i) < abs(j);
}

void maximum_guest()
{
	vector<int> time;
	for (int i=0; i<10; ++i)
	{
		time.push_back(+g[i].arrival);
		time.push_back(-g[i].leave);
	}

	sort(time.begin(), time.end(), cmp);

	int n = 0, maximum = 0;
	for (int i=0; i<time.size(); ++i)
	{
		if (time[i] >= 0)
			n++;
		else
			n--;

		maximum = max(maximum, n);
	}
	cout << "人潮最多的時段有" << maximum << "人";
}
</textarea>
<p>此處僅找出人數。找出人潮最多的時段，就留給各位自行嘗試吧。</p>
<p class="e">UVa 688 972 10613 10585 10963</p>
<p class="e">UVa 308 837</p>
<p class="t">範例：儲存座標</p>
<p>遞增的標的，主為點，次為座標軸。</p>
<img src="Incremental6.png">
<textarea>
struct Point {float x, y;} p[5] =
{
	{0, 1}, {1, 2}, {3, 0}, {2, 2}, {3, 1}
};
</textarea>
<p>遞增的標的，主為座標軸，次為點。</p>
<img src="Incremental7.png">
<textarea>
float x[5] = {0, 1, 3, 2, 3};
float y[5] = {1, 2, 0, 2, 1};
</textarea>
<p class="t">範例：印出轉換成小寫的字串</p>
<img src="Incremental8.png">
<p>有需要改變的，只有大寫字母──如果是大寫字母，就轉換成小寫字母並且印出；如果不是大寫字母，就直接印出。</p>
<textarea>
void print_lowercase()
{
	char s[15] = "Hello World!";

	for (int i=0; s[i]; i++)
		if (s[i] >= 'A' && s[i] <= 'Z')
			cout << s[i] - 'A' + 'a';
		else
			cout << s[i];
}
</textarea>
<p>也可以一步一步進行：（一）複製一份字串（二）字串統一換成小寫（三）印出字串。</p>
<textarea>
void print_lowercase()
{
	char s[15] = "Hello World!";
	char t[15];

	// 第一波：複製字串
	for (int i=0; s[i]; i++)
		t[i] = s[i];

	// 第二波：換成小寫
	for (int i=0; s[i]; i++)
		if (t[i] >= 'A' && t[i] <= 'Z')
			t[i] = t[i] - 'A' + 'a';

	// 第三波：印出字串
	cout << t;
}
</textarea>
<textarea>
void print_lowercase()
{
	char s[15] = "Hello World!";
	char t[15];

	// 每一波的程式碼可以自行包裝成為函式，
	// 亦可套用內建函式庫。
	my_copy(s, t);		// 複製字串
	my_lowercase(t);	// 換成小寫
	cout << t;			// 印出字串
}
</textarea>
<p>第一種解法稱作one-pass，資料只會讀取一遍。讀取資料的同時，也一口氣處理掉所有事情。</p>
<p>第二種解法稱作multi-pass，資料會重複讀取許多遍。所有事情劃分成數個階段，逐步處理，每個階段只專心處理一件事情。</p>
<p>one-pass的優點是：程式碼簡短、執行時間也短。缺點是：程式碼不易編修。</p>
<p>multi-pass的優點是：程式碼一目了然，容易編修、測試、除錯；程式碼可以包裝成為函式，也有機會套用內建函式庫。缺點是：需要額外的暫存記憶體。</p>
<p>這兩種方式各有利弊。程式員必須自行取捨。</p>
<p class="t">範例：對調數字</p>
<p>利用一個變數，暫存其中一個數字，以便對調。</p>
<img src="Incremental9.png">
<textarea>
void swap_int()
{
	int a = 0, b = 1;

	// 交換a與b
	int temp = a;
	a = b;
	b = temp;

	cout << a << ' ' << b;
}
</textarea>
<textarea>
void swap_int(int& a, int& b)
{
	int temp = a;
	a = b;
	b = temp;
}
</textarea>
<p class="t">範例：對調陣列</p>
<p>節省記憶體的方法：採用遞增法，逐一對調數字。</p>
<img src="Incremental10.png">
<textarea>
void swap_int_array()
{
	int a[5] = {3, 6, 9, -8, 1};
	int b[5] = {9, 8, 7, 6, 5};

	// one-pass
	for (int i=0; i<5; ++i)
	{
		int temp = a[i];
		a[i] = b[i];
		b[i] = temp;
	}
}
</textarea>
<p>浪費記憶體的方法：建立一條陣列，暫存其中一條陣列。</p>
<img src="Incremental11.png">
<textarea>
void swap_int_array()
{
	int a[5] = {3, 6, 9, -8, 1};
	int b[5] = {9, 8, 7, 6, 5};

	// multi-pass
	int temp[5];
	for (int i=0; i<5; ++i) temp[i] = a[i];
	for (int i=0; i<5; ++i) a[i] = b[i];
	for (int i=0; i<5; ++i) b[i] = temp[i];
}
</textarea>
<textarea>
void swap_int_array()
{
	int a[5] = {3, 6, 9, -8, 1};
	int b[5] = {9, 8, 7, 6, 5};

	// multi-pass
	int temp[5];
	my_copy(a, temp);
	my_copy(b, a);
	my_copy(temp, b);
}
</textarea>

</div></div><div class="a"><div class="h">
<p class="b">Memoization</p>
<p class="w">惟事事，乃其有備，有備無患。《書經》</p>
</div><div class="c">
<p class="t">Memoization</p>
<p>「記憶法」是符合電腦運作特性的方法。電腦擁有大量儲存空間。只要將計算過的數值，儲存於記憶體，往後就能直接使用記憶體儲存的資料，不必再浪費時間重複計算一遍。</p>
<pre>
Memoization（Tabulation）
演算法執行過程之中，即時更新數值，儲存於記憶體。
例如堆疊的大小。

Preprocessing（Precalculation）
演算法開始之時，預先計算數值，儲存於記憶體。
例如圓周率、字串的長度、質數的表格。
</pre>
<p>如果要儲存大量的、同性質的數值，我們可以將這些數值整理成一個表格（通常是陣列），以方便查閱──稱作「查詢表lookup table」。例如質數表便是一個「查詢表」。</p>
<p class="t">範例：陣列大小</p>
<p>使用一個變數，紀錄資料數量，以便迅速地增加資料。</p>
<img src="Memoization1.png">
<textarea>
void array_size()
{
	int array[100];
	int n = 0;		// 使用一個變數，紀錄資料數量。
	array[n++] = 3;	// 以便迅速地增加資料。
	array[n++] = 6;
	array[n++] = 9;
	cout << n;
}
</textarea>
<p>C++程式語言的標準函式庫的stack，事實上也額外隱含了一個變數，紀錄資料數量。當堆疊塞入資料、彈出資料的時候，也就是呼叫push函式、呼叫pop函式的時候，就默默更新資料數量。</p>
<textarea>
void stack_size()
{
	stack<int> s;		// C++ STL <stack>
	s.push(1);			// 默默地n++
	s.pop();			// 默默地--n
	cout << s.size();	// 把n印出來
}
</textarea>
<p class="t">範例：加總數字</p>
<p>利用一個變數，累計數字的總和。</p>
<img src="Memoization2.png">
<textarea>
void summation()
{
	int array[5] = {3, 6, 9, -8, 1};

	int sum = 0;
	for (int i=0; i<5; i++)
		sum += array[i];

	cout << "總和是" << sum;
}
</textarea>
<textarea>
int summation(int array[], int n)
{
	int sum = 0;
	for (int i=0; i<n; i++)
		sum += array[i];
	return sum;
}
</textarea>
<p class="t">範例：統計字母數量</p>
<p>建立26格的陣列，讓字母a到z依序對應陣列的每一格，作為lookup table。一邊讀取字串，一邊累計字母出現次數。</p>
<img src="Memoization3.png">
<textarea>
void count_letter()
{
	char s[15] = "Hello World!";
	int c[26] = {0};

	// 字母一律換成小寫
	for (int i=0; s[i]; i++)
		if (s[i] >= 'A' && s[i] <= 'Z')
			s[i] = s[i] - 'A' + 'a';

	// 統計字母數量
	for (int i=0; s[i]; i++)
		if (s[i] >= 'a' && s[i] <= 'z')
			c[s[i] - 'a']++;

	// 印出統計結果
	for (int i=0; i<26; i++)
		cout << char('a'+i) << ':' << c[i] << '\n';
}
</textarea>
<p class="e">UVa 10260 10082 10222 12626</p>
<p class="t">範例：統計數字數量</p>
<p>當數字範圍太大，無法建立那麼大的陣列，可以改用hash table、binary search tree等等資料結構作為lookup table。</p>
<img src="Memoization4.png">
<textarea>
void count_number()
{
	int array[10] =
	{
		1, 3, 4, 10, 11,
		1000000000, 23, 99, 123, 514
	};
//	int c[1000000000] = {0};
	map<int, int> c;	// binary search tree

	// 統計數字數量
	for (int i=0; i<10; i++)
		c[array[i]]++;

	// 印出統計結果
	for (auto i=c.begin(); i!=c.end(); ++i)
		cout << i->first << ':' << i->second << '\n';
}
</textarea>
<p class="e">UVa 11572 141</p>
<p class="t">範例：計數排序法（Counting Sort）</p>
<p>建立足夠長的陣列，讓數字對應陣列的每一格，作為lookup table。統計每個數字的出現次數。由小到大讀取lookup table，順便排序數字。</p>
<img src="Memoization5.png">
<textarea>
void count_number()
{
	int array[5] = {3, 6, 9, 9, 1};
	int c[9 + 1] = {0};

	// 統計數字數量
	for (int i=0; i<5; i++)
		c[array[i]]++;

	// 由小到大讀取lookup table，順便排序數字。
	for (int j=0, i=0; j<10 && i<5; ++j)
		while (c[j] > 0)
		{
			c[j]--;
			array[i++] = j;
		}
}
</textarea>
<p class="t">範例：求1到n的全部整數的立方和，n的範圍由1到10。</p>
<img src="Memoization6.png">
<p>以直接的方式，累加每個立方數。（儘管這個問題有公式解，但是為了方便舉例，所以這裡不採用公式解。）</p>
<textarea>
int sum_of_cubes(int n)
{
	int sum = 0;
	for (int i=1; i<=n; i++)
		sum += i * i * i;
	return sum;
}

void print_sum_of_cubes()
{
	int n;
	while (cin >> n && n > 0)
		cout << sum_of_cubes(n);
}
</textarea>
<p>使用Memoization。建立11格的陣列，每一格依序對應0到10的立方數，作為lookup table。一旦計算完畢，就儲存至表格；往後就直接讀取表格，不需重複計算。</p>
<textarea>
int sum_of_cubes(int n)
{
	// 其值為 0 表示沒有存入答案
	static int answer[10 + 1] = {};

	// 如果已經計算過，就直接讀取表格的答案。
	if (answer[n] != 0) return answer[n];

	// 如果不曾計算過，就計算一遍，儲存答案。
	int sum = 0;
	for (int i=1; i<=n; i++)
		sum += i * i * i;
	return answer[n] = sum;
}

void print_sum_of_cubes()
{
	int n;
	while (cin >> n && n > 0)
		cout << sum_of_cubes(n);
}
</textarea>
<p>使用Preprocessing。</p>
<textarea>
void print_sum_of_cubes()
{
	// 預先建立立方數表格
	int cube[10 + 1];
	for (int i=1; i<=10; ++i)
		cube[i] = i * i * i;

	int n;
	while (cin >> n && n > 0)
	{
		// 直接讀取表格的立方數
		int sum = 0;
		for (int i=1; i<=n; ++i)
			sum += cube[i];
		cout << sum;
	}
}
</textarea>
<p>Preprocessing當然也可以直接算答案啦。</p>
<textarea>
int sum_of_cubes(int n)
{
	int sum = 0;
	for (int i=1; i<=n; i++)
		sum += i * i * i;
	return sum;
}

void print_sum_of_cubes()
{
	// 預先計算所有答案
	int answer[10 + 1];
	for (int i=1; i<=10; ++i)
		answer[i] = sum_of_cubes(i);

	// 直接讀取表格的答案
	int n;
	while (cin >> n && n > 0)
		cout << answer[n];
}
</textarea>
<p>最後是Preprocessing的極致。</p>
<textarea>
void print_sum_of_cubes()
{
	// 預先計算答案，寫死在程式碼裡面。
	int answer[10 + 1] =
	{
		0, 1, 9, 36, 100, 225,
		441, 784, 1296, 2025, 3025
	};

	// 直接讀取表格的答案
	int n;
	while (cin >> n && n > 0)
		cout << answer[n];
}
</textarea>
<p class="e">UVa 10738 10894</p>
<p class="t">範例：印出方框</p>
<p>建立二維陣列：陣列的格子，依序對應視窗的文字。</p>
<img src="Memoization7.png">
<p>不直接印出方框，而是間接填至陣列。不必數空白鍵，只需兩條水平線和兩條垂直線。</p>
<textarea>
void print_square_border()
{
	// 建立記憶體
	char array[5][5];

	// 預先填入空白鍵
	for (int i=0; i<5; ++i)
		for (int j=0; j<5; ++j)
			array[i][j] = ' ';

	// 填入方框：兩條水平線、兩條垂直線
	// 即便相互重疊也無所謂
	for (int i=0; i<5; ++i) array[0][i] = '@';
	for (int i=0; i<5; ++i) array[4][i] = '@';
	for (int i=0; i<5; ++i) array[i][0] = '@';
	for (int i=0; i<5; ++i) array[i][4] = '@';

	// 印出方框
	for (int i=0; i<5; ++i)
	{
		for (int j=0; j<5; ++j)
			cout << array[i][j];
		cout << '\n';
	}
}
</textarea>
<p class="e">UVa 105 706</p>
<p class="t">範例：拆開迴圈（Loop Unrolling）</p>
<img src="Memoization8.png">
<p>迴圈語法的功能是：一段指令，重覆實施數次，但是每次都稍微變動一點點。</p>
<p>事實上，我們可以反璞歸真，拆開迴圈，還原成數行指令。如此一來，就節省了迴圈每次累加變數的時間，也節省了迴圈每次判斷結束條件的時間。</p>
<p>拆開迴圈是一種Preprocessing，預先計算迴圈變量、預先計算迴圈結束條件。</p>
<p>拆開迴圈之後，雖然提高了程式的執行速度，但是降低了程式可讀性。程式員必須自行取捨。</p>

</div></div><div class="a"><div class="h">
<p class="b">Enumeration</p>
<p class="w">愚者千慮，必有一得。《史記》</p>
</div><div class="c">
<p class="t">Enumeration</p>
<p>「枚舉法」利用了電腦無與倫比的計算速度。找到不確定的變數，枚舉所有可能性，逐一判斷正確性。</p>
<pre>
Enumerate
一筆一筆列出所有資料。
對應到程式語言的for。

Search
瀏覽所有資料，找出需要的部份。
對應到程式語言的for加if。
</pre>
<p>收集充分資訊，就能解決問題。</p>
<img src="Enumeration1.png">
<p class="t">範例：枚舉一百個平方數</p>
<p>採用直接法：依序枚舉數字1到100；枚舉過程當中，將數字平方得到平方數。</p>
<img src="Enumeration2.png">
<textarea>
void generate_squares()
{
	for (int i=1; i<=100; i++)
		cout << i*i << "是平方數";
}
</textarea>
<p>採用試誤法：依序枚舉數字1到∞；枚舉過程當中，判斷數字是不是平方數。</p>
<img src="Enumeration3.png">
<textarea>
void generate_squares()
{
	for (int i=1; i<=100*100; i++)
	{
		int sqrt_i = sqrt(i);
		if (sqrt_i * sqrt_i == i)
			cout << i << "是平方數";
	}
}
</textarea>
<p class="t">範例：尋找陣列裡的最小值</p>
<p>由小到大枚舉陣列索引值，逐一比較陣列元素。</p>
<img src="Enumeration4.png">
<textarea>
void find_minimum()
{
	int array[5] = {3, 6, 9, -8, 1};

	int min = 2147483647;
	for (int i=0; i<5; i++)	// 枚舉索引值
		if (array[i] < min)	// 比較元素
			min = array[i];	// 隨時紀錄最小值

	cout << "最小的數字是" << min;
}
</textarea>
<textarea>
int find_minimum(int array[], int n)
{
	int min = 2147483647;
	for (int i=0; i<n; i++)	// 枚舉索引值
		if (array[i] < min)	// 比較元素
			min = array[i];	// 隨時紀錄最小值
	return min;
}
</textarea>
<p class="t">範例：尋找陣列裡的特定數字</p>
<p>找到所有特定數字：瀏覽一遍所有數字。</p>
<img src="Enumeration5.png">
<textarea>
void find_all_number()
{
	int array[5] = {3, 6, 9, -8, 1};

	for (int i=0; i<5; i++)	// 枚舉
		if (array[i] == 6)	// 搜尋
			cout << i << ':' << array[i] << '\n';
}
</textarea>
<p>找到其中一個特定數字：一旦找到，立即停止瀏覽，以節省時間。</p>
<img src="Enumeration6.png">
<textarea>
bool find_number()
{
	int array[5] = {3, 6, 9, -8, 1};

	for (int i=0; i<5; i++)	// 枚舉
		if (array[i] == 6)	// 搜尋
		{
			cout << i << ':' << array[i];
			break;
		}
}
</textarea>
<textarea>
int find_number(int array[i], int n, int num)
{
	for (int i=0; i<n; i++)
		if (array[i] == num)
			return i;
	return -1;
}
</textarea>
<p class="t">範例：尋找二維陣列裡的特定數字</p>
<img src="Enumeration7.png">
<p>多個元素成為一個橫條、多個橫條成為一個陣列。內層先枚舉元素，外層再枚舉橫條，就能枚舉所有元素。</p>
<p>方才是由內而外、由小到大進行思考，其實也可以由外而內、由大到小進行思考：外層先枚舉每一個橫條，內層再枚舉一個橫條的每一個元素，就能枚舉所有元素。</p>
<textarea>
bool find(int n)
{
	int array[3][5] =
	{
		{3, 6, 9, -8, 1},
		{2, 4, 6, 8, 10},
		{11, 7, 5, 3, 2}
	};

	// 外層枚舉每一個橫條
	for (int i=0; i<3; i++)
		// 內層枚舉一個橫條的每一個元素
		for (int j=0; j<5; j++)
			// 就能枚舉所有元素
			if (array[i][j] == n)
				return true;
	return false;
}
</textarea>
<p>此處再介紹一種特別的思考方式：第一層枚舉每一個橫條，第二層枚舉每一個直條，就能枚舉所有直條與橫條的交錯之處。</p>
<p>雖然前後兩個思考方式完全不同，但是前後兩支程式碼卻完全相同。</p>
<textarea>
bool find(int n)
{
	int array[3][5] =
	{
		{3, 6, 9, -8, 1},
		{2, 4, 6, 8, 0},
		{7, 5, 3, 2, 1}
	};

	// 第一層枚舉每一個橫條
	for (int i=0; i<3; i++)
		// 第二層枚舉每一個直條
		for (int j=0; j<5; j++)
			// 就能枚舉所有橫條與直條交錯之處
			if (array[i][j] == n)
				return true;
	return false;
}
</textarea>
<p class="t">範例：平面上距離最近的兩個點（Closest Pair Problem）</p>
<img src="Enumeration8.png">
<p>第一層枚舉第一個點，第二層枚舉第二個點。為了避免重複枚舉相同的一對點，第二層只枚舉索引值更高的點。</p>
<textarea>
void closest_pair()
{
	float point[10][2] =
	{
		{3, 3}, {1, 5}, {4, 6}, {2, 8}, {9, 9},
		{2, 1}, {7, 2}, {6, 5}, {9, 4}, {5, 9}
	};

	// 距離最近的兩個點的距離
	float d = 1e9;

	// 枚舉第一點
	for (int i=0; i<10; i++)
		// 枚舉第二點
		for (int j=i+1; j<10; j++)
		{
			// 計算第一點到第二點的距離
			float dx = point[i][0] - point[j][0];
			float dy = point[i][1] - point[j][1];
			float dij = sqrt(dx * dx + dy * dy);

			// 紀錄最短的距離
			if (dij < d) d = dij;
		}
	cout << "距離是" << d;
}
</textarea>
<p>可以把計算距離的程式碼，抽離出來成為一個函式。好處是程式碼變得清爽許多，增加程式碼可讀性。壞處是大量呼叫函式，導致執行速度變慢。</p>
<textarea>
struct Point {float x, y;};

// 計算兩點之間的距離
float dist(Point& a, Point& b)
{
	float dx = a.x - b.x;
	float dy = a.y - b.y;
	return sqrt(dx * dx + dy * dy);
}

void closest_pair()
{
	Point point[10] =
	{
		{3, 3}, {1, 5}, {4, 6}, {2, 8}, {9, 9},
		{2, 1}, {7, 2}, {6, 5}, {9, 4}, {5, 9}
	};

	float d = 1e9; 
	for (int i=0; i<10; i++) 
		for (int j=i+1; j<10; j++)
			// 紀錄最短的距離
			d = min(d, dist(point[i], point[j]));

	cout << "距離是" << d;
}
</textarea>
<p>魚與熊掌不可兼得，這兩種程式碼各有優缺點，沒有絕對的好壞。程式員必須自行取捨。</p>
<p class="t">範例：字串匹配（String Matching）</p>
<p>從長字串之中，找到短字串的出現位置。</p>
<img src="Enumeration9.png">
<p>第一層先枚舉所有可以匹配的位置，第二層再枚舉所有需要匹配的字元。</p>
<textarea>
void string_matching()
{
	char text[15] = "It's a pencil.";
	char pattern[6] = "a pen";

	// 枚舉所有可以匹配的位置
	for (int i=0; i<14; i++)
	{
		// 枚舉所有需要匹配的字元
		bool match = true;
		for (int j=0; j<5; j++)
			if (text[i+j] != pattern[j])
				match = false;

		if (match)
			cout << "短字串出現在第" << i << "個字元";
	}
}
</textarea>
<p>因為短字串不會超出長字串末段，所以第一層枚舉範圍可以再略微縮小。</p>
<p>因為只要一個相異字元，就足以表明匹配位置錯誤，所以第二層的枚舉過程可以提早結束。</p>
<textarea>
void string_matching()
{
	char text[14] = "It's a pencil.";
	char pattern[6] = "a pen";

	// 仔細估量枚舉範圍
	for (int i=0; i<14-6+1; i++)
	{
		bool match = true;
		for (int j=0; j<5; j++)
			if (text[i+j] != pattern[j])
			{
				match = false;
				break;
			}

		if (match)
			cout << "短字串出現在第" << i << "個字元";
	}
}
</textarea>
<p class="t">範例：統計字母數量</p>
<img src="Enumeration10.png">
<p>第一層先枚舉26種英文字母，第二層再枚舉字串的所有字元，計算一種字母的數量。</p>
<textarea>
void count_letter()
{
	char s[15] = "Hello World!";

	// 字母統一換成小寫
	for (int i=0; s[i]; i++)
		if (s[i] >= 'A' && s[i] <= 'Z')
			s[i] = s[i] - 'A' + 'a';

	// 枚舉26種英文字母
	for (int i=0; i<26; i++)
	{
		// 枚舉字串的所有字元
		int c = 0;
		for (int j=0; s[j]; j++)
			if (s[j] == 'a' + i)
				c++;

		// 印出一種字母的數量
		cout << (char)('a' + i) << ':' << c;
	}
}
</textarea>
<p>先前曾經介紹過統計字母數量的範例。先前範例當中，雖然耗費記憶體空間，但是執行速度快──簡單來說就是空間大、時間小。此處範例當中，則是空間小，時間大，恰恰相反。這兩種方式各有優缺點，程式員必須自行取捨。</p>
<p class="t">範例：反轉字串</p>
<img src="Enumeration11.png">
<p>兩個枚舉，一個從頭到尾，一個從尾到頭，步調相同，逐步對調字元。雖然是兩個枚舉，卻只有一個迴圈。</p>
<textarea>
void reverse_string()
{
	char s[15] = "Hello World!";

	// 兩個枚舉，一個從頭到尾，一個從尾到頭。
	for (int i=0, j=12; i<j; i++, j--)
		swap(s[i], s[j]);

	cout << "反轉之後的字串是" << s;
}
</textarea>
<textarea>
void reverse(char* s)
{
	int n = strlen(s);
	for (int i=0; i<n/2; i++)
		swap(s[i], s[n-1-i]);
}
</textarea>
<p class="e">UVa 1595</p>
<p class="t">範例：尋找總和為10的區間</p>
<p>假設陣列元素只有正數。</p>
<img src="Enumeration12.png">
<p>兩個枚舉，枚舉區間左端以及枚舉區間右端，都是從頭到尾，保持一左一右，視情況輪流枚舉。雖然是兩個枚舉，卻只有一個迴圈。</p>
<textarea>
void find_interval()
{
	int array[5] = {3, 6, 1, 7, 2};

	int sum = 0;
	for (int i=0, j=-1; j<5; )	// 枚舉區間[i, j]
	{
		if (sum > 10)
		{
			// 總和太大，區間左端往右縮短。
			sum -= array[i];
			i++;
		}
		else if (sum < 10)
		{
			// 總和太小，區間右端往右伸長。
			j++;
			sum += array[j];
		}
		else if (sum == 10)
		{
			// 總和剛好，
			// 區間左端往右縮短，
			// 亦得區間右端往右伸長。
			// 任選一種皆可。
//			sum -= array[i];
//			i++;
			j++;
			sum += array[j];
		}

		if (sum == 10)
			cout << '[' << i << ',' << j << ']';
	}
}
</textarea>
<textarea>
void find_interval(int array[], int n, int num)
{
	int sum = 0;
	for (int i=0, j=0; j<=n; )	// 枚舉區間[i, j)
	{
		if (sum > num)
			sum -= array[i++];
		else
			sum += array[j++];

		if (sum == num)
			cout << '[' << i << ',' << j-1 << ']';
	}
}
</textarea>
<p>讀者可以想想看：陣列元素若有零、有負數，是否要調整枚舉方式？</p>
<p class="e">UVa 972 10464 11536 11572</p>
<p class="t">範例：尋找陣列之中的最小值，陣列已經由小到大排序</p>
<p>找到其中一個最小值：經常整理房間，尋找東西就快；預先排序資料，搜尋速度就快。</p>
<img src="Enumeration13.png">
<textarea>
void find_minimum()
{
	int array[5] = {3, 3, 6, 6, 9};
	cout << "最小的數字是" << array[0];
}
</textarea>
<p>找到所有最小值：讀者請自行嘗試。</p>
<p class="t">範例：尋找陣列之中的特定數字，陣列已經由小到大排序</p>
<p>找到其中一個特定數字：首先找到陣列中央的數字，依其數字大小，繼續搜尋左半段或者右半段。</p>
<img src="Enumeration14.png">
<textarea>
void find_number()
{
	int array[15] =
	{
		2, 3, 5, 7, 11,
		13, 17, 19, 23, 29,
		31, 37, 41, 43, 47
	};

	int left = 0, right = 15-1;
	while (left <= right)
	{
		int mid = (left + right) / 2;
		if (array[mid] < 29)
			left = mid + 1;		// 繼續搜尋剩下的右半段
		else if (array[mid] > 29)
			right = mid - 1;	// 繼續搜尋剩下的左半段
		else if (array[mid] == 29)
		{
			// 找到了其中一個數字
			cout << mid << ':' << array[mid];
			return;
		}
	}

	cout << "找不到29";
}
</textarea>
<p>找到所有特定數字：讀者請自行嘗試。</p>
<p class="t">範例：平面上距離最近的兩個點（Closest Pair Problem）</p>
<img src="Enumeration15.png">
<p>找到距離最近的其中一對點：預先依照X座標排序所有點，搜尋得以略過大量情況。</p>
<textarea>
struct Point {float x, y;};

// 計算兩點之間的距離
float dist(Point& a, Point& b)
{
	float dx = a.x - b.x;
	float dy = a.y - b.y;
	return sqrt(dx * dx + dy * dy);
}

bool cmp(const Point& i, const Point& j)
{
	return i.x < j.x;
}

void closest_pair()
{
	Point point[10] =
	{
		{3, 3}, {1, 5}, {4, 6}, {2, 8}, {9, 9},
		{2, 1}, {7, 2}, {6, 5}, {9, 4}, {5, 9}
	};

	// 依照X座標排序所有點
	sort(point, point+10, cmp);

	float d = 1e9; 
	for (int i=0; i<N; ++i)
		for (int j=i+1; j<N; ++j)
		{
			// 兩個點的X座標已經相距太遠，直接略過，
			// 繼續枚舉下一個左端點。
			if (p[j].x - p[i].x > d) break;
			d = min(d, dist(point[i], point[j]));
		}

	cout << "距離是" << d;
}
</textarea>
<p>找到距離最近的每一對點：讀者請自行嘗試。</p>
<p class="t">範例：英文單字從單數變複數</p>
<p>枚舉各種情況，寫成大量判斷式。</p>
<img src="Enumeration16.png">
<textarea>
void plural(string s)
{
	int n = s.length();
	if (s.back() == 'y')
		cout << s.substr(0, n-1) << "ies";
	else if (s.back() == 's' || s.back() == 'x')
		cout << s << "es";
	else if (s.substr(n-2) == "sh" || s.substr(n-2) == "ch")
		cout << s << "es";
	else if (s.substr(n-3) == "man")
		cout << s.substr(0, n-3) << "men";
	else
		cout << s << 's';
}
</textarea>
<p class="t">範例：小畫家倒墨水（Flood Fill Algorithm）</p>
<p>電腦圖片可以想成是一張方格紙，每個方格都填著一種顏色。現在要實現小畫家倒墨水的功能：以某一格為起點，只要相鄰方格顏色一樣，就染成同一個顏色。</p>
<img src="Enumeration17.png">
<p>運用大量指令，枚舉上下左右四個方向；運用遞迴，枚舉相鄰同色方格。</p>
<p>必須避免已經枚舉過的方格又重複枚舉，否則程式在有生之年都不會結束。</p>
<textarea>
int image[10][10];	// 圖片的大小為 10x10

void flood(int x, int y, int new_color, int old_color)
{
	if (x>=0 && x<10 && y>=0 && y<10)	// 不能超出邊界
		if (image[x][y] == old_color)	// 同色方格才枚舉
		{
			// 染色
			image[x][y] = new_color;
			// 枚舉上下左右四個方向
			flood(x+1, y, new_color, old_color);
			flood(x-1, y, new_color, old_color);
			flood(x, y+1, new_color, old_color);
			flood(x, y-1, new_color, old_color);
		}
}

void ink()
{
	// 在座標(7,6)的方格，淋上1號顏色。
	flood(7, 6, 1, image[7][6]);
}
</textarea>
<p>大量指令，亦得寫成一個迴圈。</p>
<textarea>
void flood(int x, int y, int new_color, int old_color)
{
	if (x>=0 && x<10 && y>=0 && y<10)
		if (image[x][y] == old_color)
		{
			image[x][y] = new_color;

			// 寫成一個迴圈
			for (int i=0; i<4; i++)
			{
				static int dx[4] = {1, -1, 0, 0};
				static int dy[4] = {0, 0, 1, -1};
				flood(x + dx[i], y + dy[i], new_color, old_color);
			}
		}
}
</textarea>
<p>多層判斷式，亦得拆解成一層一層的判斷式。</p>
<textarea>
void flood(int x, int y, int new_color, int old_color)
{
	if (!(x>=0 && x<10 && y>=0 && y<10)) return;
	if (image[x][y] != old_color) return;

	image[x][y] = new_color;

	for (int i=0; i<4; i++)
	{
		static int dx[4] = {1, -1, 0, 0};
		static int dy[4] = {0, 0, 1, -1};
		flood(x + dx[i], y + dy[i], new_color, old_color);
	}
}
</textarea>
<p class="e">UVa 260 280 352 469 572 601 657 776 782 784 785 871 10267 10336 10946</p>
<p class="e">ICPC 4792 5130</p>
<p class="t">Straightforward Method / Trial and Error</p>
<p>「直接法」，直接算出答案。例如按照流程進行得到答案、套用公式計算答案、直接印出答案。</p>
<p class="e">UVa 488 10055 10370 10878 10929</p>
<p>「嘗試錯誤法」、「試誤法」，針對答案進行Enumerate與Search。有些困難的問題，難以直接推導答案，既然推導不出來，就慢慢測試答案、慢慢驗算吧──確立答案的範圍，窮舉所有可能的答案，再從中搜尋正確答案。</p>
<p class="e">UVa 10167 10125 296 846 714</p>
<p>直接法和試誤法剛好相反。直接法是由題目本身下手，推導答案；試誤法則是從答案下手，讓答案迎合題目需求。</p>
<img src="Enumeration18.png">
<p class="t">範例：暴力攻擊（Brute Force Attack）</p>
<p>破解密碼最簡單的方法叫做「暴力攻擊」。不知道密碼規律的情況下，無法直接推導正確密碼，只好以試誤法一一檢驗所有可能的密碼，從中找出正確密碼。</p>
<img src="Enumeration19.png">
<p class="t">範例：單向函數（One-way Function）</p>
<p>「單向函數」是一種特別的函數，給定輸入很容易算出輸出，但是給定輸出卻很難算出輸入。</p>
<img src="Enumeration20.png">
<p>舉例來說，令一個函數的輸入是兩個質數，輸出是兩個質數的乘積。給定兩個質數可以輕易的在多項式時間內算出乘積，然而給定兩質數的乘積卻需要指數時間才能完成質因數分解。</p>
<p>如果給定一個單向函數的輸入，求其輸出，就適合用直接法，套用函數快速算得答案；如果給定一個單向函數的輸出，求其輸入，就適合用試誤法，嘗試各種輸入並套用函數快速驗證答案。</p>

</div></div><div class="a"><div class="h">
<p class="b">Iterative Method</p>
<p class="w">道生一，一生二，二生三，三生萬物。《老子》</p>
</div><div class="c">
<p class="t">Iterative Method</p>
<p>繁中「疊代法」、簡中「递推法」。不斷利用目前求得的數值，再求得新數值。</p>
<p class="e">UVa 997</p>
<p class="t">範例：字串變整數</p>
<img src="Iterative1.png">
<p>直覺的方式是遞增法。個、十、百、千、萬、……，每個位數分別乘上10的次方，通通加起來。此處按照高位數到低位數的順序進行處理，以符合字串的儲存順序。</p>
<img src="Iterative2.png">
<textarea>
// 計算字串長度
int string_length(char* s)
{
	int n = 0;
	while (s[n]) n++;
	return n;
}

// 計算10的exp次方
int pow10(int exp)
{
	int n = 1;
	for (int i=0; i<exp; i++)
		n *= 10;
	return n;
}

void string_to_integer()
{
	char s[10] = "26962869";

	// 預先計算字串長度。
	int length = string_length(s);

	// 依序處理高位數到低位數。
	int n = 0;
	for (int i=0; i<length; i++)
		n += (s[i] - '0') * pow10(length - 1 - i);

	cout << n;
}
</textarea>
<p>更好的方式是遞推法！由高位數到低位數、也就是由左到右讀取字串，每讀取一個字元，就將數值乘以十、加上當前字元的對應數字。</p>
<img src="Iterative3.png">
<textarea>
void string_to_integer()
{
	char s[10] = "26962869";

	int n = 0;
	for (int i=0; s[i]; i++)
		n = n * 10 + s[i] - '0';

	cout << n;
}
</textarea>
<p>同一個問題，有著不同的解法。有著程式碼很長、執行速度很慢的方法，也有著程式碼很短，執行速度很快的方法。一支程式的好壞，除了取決於正確性和可讀性之外，同時也取決於計算方法。</p>
<p class="e">UVa 759</p>
<p class="t">範例：秦九韶演算法（Horner's Rule）</p>
<p>多項式函數，代入數值。一乘一加，不斷更迭，求得函數值。完全不需要次方運算。</p>
<img src="Iterative4.png">
<p class="t">範例：除法</p>
<p>不斷乘以十、除以除數，就是一種遞推。</p>
<img src="Iterative5.png">
<p class="t">範例：牛頓法（Newton's Method）</p>
<p>找到連續函數等於零的位置。一開始隨便設定一個位置，不斷利用斜率求出下一個位置，就是一種遞推。</p>
<pre>
Xn+1 = Xn - f(Xn) / f'(Xn)
</pre>
<img src="Iterative6.png">
<p class="t">範例：3n+1猜想（Collatz Conjecture）</p>
<p>猜想的內容是這樣的：有一個整數，如果是偶數，就除以2；如果是奇數，就乘以3再加1。一個整數不斷這樣操作下去，最後一定會變成1。這個操作的過程就是一種遞推。</p>
<img src="Iterative7.png">
<p>至今尚未有人能夠證明其正確性。有趣的是，目前也尚未檢查出任何反例。</p>
<p class="e">UVa 100 371 694</p>
<p class="t">範例：生命遊戲（Cellular Automaton）</p>
<p>一個二維的方格平面，每個格子都有一個細胞，可能是活的，可能是死的。細胞的生命狀況，隨時間變動，變動規則如下：</p>
<pre>
復活：一個死的細胞，若是它的八個鄰居，有三個細胞是活的，則在下一刻復活。
存活：一個活的細胞，若是它的八個鄰居，有兩個或三個細胞是活的，則在下一刻存活。
死於孤單：一個活的細胞，若是它的八個鄰居，只有零個或一個細胞是活的，則在下一刻死亡。
死於擁擠：一個活的細胞，若是它的八個鄰居，有四個以上的細胞是活的，則在下一刻死亡。
</pre>
<img src="Iterative8.png">
<p>實作時，我們可以弄兩張地圖，第一張地圖儲存現在這個時刻的狀態，第二張地圖儲存下一個時刻的狀態。兩張地圖交替使用，以節省記憶體空間。</p>
<p>細胞的變動規則，包裝成一個函式，讓程式碼易讀。</p>
<p>至今尚未有人能夠預測細胞最終會滅亡或延續。</p>
<textarea>
void go(int x, int y, bool map1[100][100], bool map2[100][100])
{
	int n = 八個鄰居中，還活著的細胞數目;

	if (!map1[x][y])
		if (n == 3)					// 復活
			map2[x][y] = true;
		else						// 仍舊死亡
			map2[x][y] = map1[x][y];
	else
		if (n == 2 || n == 3)		// 存活
			map2[x][y] = true;
		else if (n == 0 || n == 1)	// 死於孤單
			map2[x][y] = false;
		else if (n >= 4)			// 死於擁擠
			map2[x][y] = false;
}

void cellular_automata()
{
	bool map[2][100][100];

	map[0][50][50] = true;	// 自行設定一些活的細胞
	map[0][50][51] = true;
	map[0][51][50] = true;

	for (int t=0; t<100; ++t)
		for (int x=0; x<100; ++x)
			for (int y=0; y<100; ++y)
				go(x, y, map[t%2], map[(t+1)%2]);
}
</textarea>
<p class="e">UVa 447 457 10443 10507</p>
<p class="t">範例：蘭頓的螞蟻（Langton's Ant）</p>
<p>跟生命遊戲相似，不過這個遊戲更神奇。</p>
<pre>
一、格子有黑與白兩種顏色。
二、螞蟻走入白格則右轉，走入黑格則左轉。
三、螞蟻離開格子時，格子顏色顛倒。
</pre>
<p>驚人的是，乍看完全沒有規律的路線，卻在10647步之後開始循環。原因至今不明。</p>
<iframe src="http://www.youtube.com/embed/1X-gtr4pEBU"></iframe>
<p class="e">UVa 11664 ICPC 7478 7479</p>
<p class="t">範例：數學歸納法（Mathematical Induction）</p>
<p>數學歸納法的第二步驟，就是證明可不可以遞推！第二步驟的證明過程中一定會用到遞推！</p>
<pre>
1. 先證明 n = 1 成立。（有時候不見得要從1開始。）
2. 假設 n = k 成立，證明 n = k+1 也會成立。

當 1. 2. 得證，就表示 n = 1 ... ∞ 全部都成立。
</pre>
<p class="t">範例：插入排序法（Insertion Sort）</p>
<p>從表面上來看是遞增法與枚舉法：第一層是遞增法，逐一把每個數字插入到左方已排序的陣列。第二層是枚舉法，搜尋插入位置；再將大量數字往右挪，以騰出空間插入數字。</p>
<p>但是從另一個角度來看，利用目前排序好的陣列，再求出更長的陣列，其實就是遞推法。</p>
<img src="Iterative9.png">
<p class="t">範例：以試除法建立質數表</p>
<p>從表面上來看是兩層的枚舉法：第一層先枚舉正整數，一一試驗是否為質數；第二層再枚舉所有已知質數，一一試除。</p>
<p>但是從另一個角度來看，利用目前求得的質數，再求出更多質數，其實就是遞推法。</p>
<p class="t">範例：十分逼近法</p>
<p>數線分割成十等份區間，從中找出正確區間，把對應的小數位數添到答案末端，然後不斷十等分下去。</p>
<p>利用目前求得的小數，再求出更多的小數，其實就是遞推法。</p>
<img src="Iterative10.png">
<p class="t">範例：書塔（Book Stacking Problem）</p>
<p>將書本一本一本疊起來，成為一座斜塔，越斜越好。</p>
<img src="Iterative11.png">
<p>對於任何一本書來說，其上方所有書本的整體重心，必須落在這本書上，這本書才能平穩地支撐住上方所有書本。</p>
<p>將書本插入到書塔底部，讓書塔的重心落在書本邊緣，就可以讓書塔最斜。插入書本到書塔底部之後，就更新書塔的重心位置，以便稍後插入下一本書本。</p>
<p>不斷插入書本到書塔底部、更新書塔重心，運用先前的書塔求得新的書塔──這段過程就是一種遞推。</p>
<p class="t">範例：交卷</p>
<p>考試結束了，學生要交卷，老師要收卷。大家將手上的考卷，不斷傳遞給其他人，不斷匯集給老師。一個人不能同時交卷和收卷，一個人不能同時交卷給多人（搗亂），一個人不能同時向多人收卷（手忙腳亂）。假設每個人交卷速度一致，請讓整個過程越短越好。</p>
<img src="Iterative12.png">
<p>每個人隨時都在收卷交卷，一定最省時。老師亦然，一直處於收卷狀態，一定最省時。</p>
<p>遞增的標的，選定為老師。老師每次收卷，直接複製貼上前面幾次收卷的部屬方式，是最好的──這段過程就是一種遞推。</p>

</div></div><div class="a"><div class="h">
<p class="b">Recursive Method</p>
<p class="w">易有太極，是生兩儀。兩儀生四象，四象生八卦。《易傳》</p>
</div><div class="c">
<p class="t">Recursive Method</p>
<p>繁中「遞迴法」、簡中「递归法」。重複運用相同手法，縮減問題範圍，直到釐清細節。</p>
<p class="e">UVa 10994 10212 10471 10922</p>
<p class="t">範例：碎形（Fractal）</p>
<p>利用相同手法繪圖，繪圖範圍越來越精細。</p>
<p>圖中的碎形稱作Sierpinski triangle。凡是尖端朝上的正三角形，就在當中放置一個尖端朝下的正三角形；放置之後，圖形就變得更細膩，範圍就變得更小了。</p>
<img src="Recursive1.png">
<p>圖中的碎形稱作Kosh snowflake。一條邊三等分，去除中段，朝外補上兩段，形成尖角。</p>
<img src="Recursive2.png">
<p>圖中的碎形稱作Pythagorean tree。不斷繪製正方形、直角三角形，看起來像是一棵茂密的樹。</p>
<canvas id="Fractal" width="500" height="300"></canvas>
<script>
var loop = 1;
document.getElementById('Fractal').onclick = function(){DrawPythagoreanTree(280, 298, 350, 298, loop = loop % 12 + 1);};

DrawPythagoreanTree(280, 298, 350, 298, 1);
function DrawPythagoreanTree(x1, y1, x2, y2, loop) {
	var c = document.getElementById('Fractal');
	var ctx = c.getContext('2d');

	ctx.clearRect(0, 0, c.width, c.height);
	ctx.font = "32pt Arial";
	ctx.textBaseline = "top";
	ctx.strokeStyle = "rgb(0,127,0)";
	ctx.strokeText("Click Me !", 0, 0);

	ctx.beginPath();
	ctx.moveTo(x1, y1);
	ctx.lineTo(x2, y2);
	ctx.strokeStyle = "rgb(0,127,0)";
	ctx.stroke();

	DrawSquare(ctx, x1, y1, x2, y2, loop);
}

function DrawSquare(ctx, x1, y1, x2, y2, loop) {
	if (loop <= 0) return;

	var dx = x2 - x1;
	var dy = y2 - y1;

	var x3 = x2 + dy; 
	var y3 = y2 - dx;

	var x4 = x1 + dy;
	var y4 = y1 - dx;

	ctx.beginPath();
	ctx.moveTo(x2, y2);
	ctx.lineTo(x3, y3);
	ctx.lineTo(x4, y4);
	ctx.lineTo(x1, y1);
	ctx.stroke();

	DrawTriangle(ctx, x4, y4, x3, y3, loop);
}

function DrawTriangle(ctx, x1, y1, x2, y2, loop) {
	if (loop <= 0) return;

	var a = 4, b = 3;
	var c = a * a + b * b;

	var dx = x2 - x1;
	var dy = y2 - y1;

	var x3 = x1 + (dx * a + dy * b) * a / c;
	var y3 = y1 - (dx * b - dy * a) * a / c;

	ctx.beginPath();
	ctx.moveTo(x1, y1);
	ctx.lineTo(x3, y3);
	ctx.lineTo(x2, y2);
	ctx.stroke();

	DrawSquare(ctx, x1, y1, x3, y3, loop - 1);
	DrawSquare(ctx, x3, y3, x2, y2, loop - 1);
}
</script>
<p class="e">UVa 177 10609</p>
<p class="t">範例：質因數分解（Integer Factorization）</p>
<p>不斷抽取出質因數，使數值不斷變小，直到成為質因數。</p>
<img src="Recursive3.png">
<p class="t">範例：L形磁磚</p>
<p>有一個邊長為2的3次方的正方形，右上角缺了一角邊長為1的正方形。現在要以L形磁磚貼滿這個缺了一角的正方形，該如何貼呢？</p>
<img src="Recursive4.png">
<p>巧妙地將一塊L形磁磚放在中央的位置，就順利的把正方形切成四個比較小的、亦缺了一角的正方形。接下來只要遞迴處理四個小正方形，就解決問題了。</p>
<p>這個問題也可以改成缺口在任意一處，各位可以想想看怎麼解。</p>
<p class="e">UVa 10230</p>
<p class="t">範例：輾轉相除法（Euclid's Algorithm）</p>
<p>兩個數字輪流相除、求餘數，最後就得到最大公因數（greatest common divisor, gcd）。相信大家小時候都有學過。</p>
<img src="Recursive5.png">
<p>我們可以把最大公因數想像成磚塊、把兩個數字都看成是最大公因數的倍數。</p>
<p>兩數相減所得的差值，一定是最大公因數的倍數。更進一步來說，兩數相除所得的餘數，一定是最大公因數的倍數。輾轉相除法的過程當中，兩數自始至終都是最大公因數的倍數。</p>
<p>運用這個性質，我們把兩數相除、求餘數，使得原始數字不斷縮小，直到得到最大公因數。真是非常巧妙的遞歸法！</p>
<textarea>
// 運用程式語言的迴圈語法。
int gcd(int a, int b)
{
	// 令 a 比 b 大，比較容易思考。
	while (b != 0)
	{
		int t = a % b;
		a = b;
		b = t;
	}
	return a;
}
</textarea>
<textarea>
// 運用程式語言的遞迴語法。
int gcd(int a, int b)
{
	// 令 a 比 b 大，比較容易思考。
	if (b == 0)
		return a;
	else
		return gcd(b, a % b);
}
</textarea>
<p>注意到，遞推法、遞歸法，不等於程式語言中的迴圈、遞迴。遞推法、遞歸法是分析問題的方法，用來得到計算過程、用來得到演算法。至於編寫程式時，我們可以自由地採用迴圈或者遞迴。</p>
<p class="t">遞推法、遞歸法，一體兩面，同時存在。</p>
<p>遞推法與遞歸法恰好顛倒：遞推法是針對已知，逐步累積，直至周全；遞歸法是針對未知，反覆拆解，直至精確。</p>
<p>遞推法是由小到大，遞歸法是由大到小。</p>
<img src="Recursive6.png">
<p class="t">範例：秦九韶演算法（Horner's Rule）</p>
<p>遞推法是不斷配x，擴增已知；遞歸法是不斷提x，減少未知。</p>
<pre>
a * x^2 + b * x^1 + c

Iterative Method:
{a} * x^2 + b * x^1 + c
{a, *x} * x^1 + b * x^1 + c
{a, *x, +b} * x^1 + c
{a, *x, +b, *x} + c
{a, *x, +b, *x, +c}

Recursive Method:
{a * x^2 + b * x^1 + c}
{a * x^2 + b * x^1}, +c
{a * x^1 + b}, *x, +c
{a * x^1}, +b, *x, +c
{a}, *x, +b, *x, +c
</pre>
<p>雖然遞推法與遞歸法的推理方向是相反的，但是遞推法與遞歸法的計算方向是一樣的，兩者都是由小範圍算到大範圍。</p>
<pre>
Iterative Method:
a, *x, +b, *x, +c

Recursive Method:
a, *x, +b, *x, +c
</pre>
<p class="e">UVa 498 10268</p>
<p class="t">範例：爬樓梯</p>
<p>眼前有五階樓梯，一次只能踏一階或踏兩階，那麼爬到五階總共有哪幾種踏法？例如(1,1,1,1,1)是其中一種踏法，(1,2,2)是另一種踏法。</p>
<img src="Recursive7.png">
<p>這個問題可以用遞推法，也可以用遞歸法。</p>
<p>首先採用遞推法。試著只爬少少的幾階樓梯，觀察一下踏法。</p>
<p>爬到一階的踏法：很明顯的只有一種，(1)。</p>
<p>爬到兩階的踏法：有兩種，(1,1)和(2)。</p>
<p>爬到三階的踏法：因為一次只能踏一階或踏兩階，所以只可能從第一階或從第二階踏上第三階。只要綜合(爬到一階的踏法,2)與(爬到兩階的踏法,1)，就是爬到三階的踏法。</p>
<p>爬到四階的踏法：同理，綜合(爬到兩階的踏法,2)與(爬到三階的踏法,1)即得。</p>
<p>遞推下去，就可求出爬到五階的踏法。</p>
<pre>
Forward Iterative Method:
爬到一階　(1)
爬到兩階　(1,1) (2) 
爬到三階　即是(爬到一階,2)與(爬到二階,1)
　　　　　(1,2)
　　　　　(1,1,1) (2,1)
爬到四階　即是(爬到二階,2)與(爬到三階,1)
　　　　　(1,1,2) (2,2)
　　　　　(1,2,1) (1,1,1,1) (2,1,1)
爬到五階　即是(爬到三階,2)與(爬到四階,1)
　　　　　(1,2,2) (1,1,1,2) (2,1,2)
　　　　　(1,1,2,1) (2,2,1) (1,2,1,1) (1,1,1,1,1) (2,1,1,1)
</pre>
<p>前面是採用上樓梯的順序進行遞推，由第一階遞推到第五階。也可以採用下樓梯的順序進行遞推，由第五階遞推到第一階。</p>
<pre>
Backward Iterative Method:
降到四階　(1)
降到三階　(1,1) (2)
降到二階　即是(2,降到四階)與(1,降到三階)
　　　　　(2,1)
　　　　　(1,1,1) (1,2)
降到一階　即是(2,降到三階)與(1,降到二階)
　　　　　(2,1,1) (2,2)
　　　　　(1,2,1) (1,1,1,1) (1,1,2)
降到平面　即是(2,降到二階)與(1,降到一階)
　　　　　(2,2,1) (2,1,1,1) (2,1,2)
　　　　　(1,2,1,1) (1,2,2) (1,1,2,1) (1,1,1,1,1) (1,1,1,2)
</pre>
<p>有一些問題，比如爬樓梯問題，雙向都可以遞推。數值由小到大的方向稱為「正向」或「順向」（forward），數值由大到小的方向稱為「反向」或「逆向」（backward）。</p>
<p>接著採用遞歸法。由踏出的最後一步開始分析。</p>
<p>要「爬到五階」，最後一步一定是踏上第五階。要踏上第五階，只可能從第四階和第三階踏過來，也就是綜合(爬到四階的踏法,1)與(爬到三階的踏法,2)。</p>
<p>但是我們尚不知如何「爬到四階」和「爬到三階」，所以只好再分別研究「爬到四階」與「爬到三階」。不斷追究到「爬到一階」與「爬到兩階」的時候，就能確認答案了！</p>
<pre>
Forward(?) Recursive Method:
爬到五階　即是(爬到四階,1)與(爬到三階,2)
爬到四階　即是(爬到三階,1)與(爬到二階,2)
爬到三階　即是(爬到二階,1)與(爬到一階,2)
爬到兩階　(2) (1,1)
爬到一階　(1)
</pre>
<p>當然也可以雙向遞歸。就不贅述了。</p>
<p class="t">範例：格雷碼（Gray Code）</p>
<pre>
Iterative Method:
GrayCode(n-1)的每個數字，最高位數加一個0。
GrayCode(n-1)的每個數字，高位數與低位數整個顛倒，然後在最高位數加一個1。
兩者銜接起來就是GrayCode(n)。

Recursive Method:
GrayCode(n)的每個數字，分成兩類。
第一類最高位數是0，把最高位數拿掉後，即形成GrayCode(n-1)。
第二類最高位數是1，把最高位數拿掉後，即形成GrayCode(n-1)。
</pre>
<p>也可以用最低位數為主，進行遞推、遞歸，生成順序不同的Gray Code。Gray Code具有循環的特性，有多種遞推、遞歸方式，不分正向與逆向。</p>

</div></div><div class="a"><div class="h">
<p class="b">Divide and Conquer</p>
<p class="w">凡治眾如治寡，分數是也。鬥眾如鬥寡，形名是也。《孫子》</p>
</div><div class="c">
<p class="t">Divide and Conquer</p>
<p>「分治法」，分割問題、各個擊破。將一個大問題，分割成許多小問題。如果小問題還是很難，就繼續分割成更小的問題，直到問題變得容易解決。</p>
<p>分割出來的小問題，稱作「子問題subproblem」。解決一個問題，等價於解決所有子問題。</p>
<p>用樹狀圖表達原問題與子問題的關係，最好不過！</p>
<img src="DivideAndConquer1.png">
<p>分治法著重分割問題的方式──要怎麼分割問題，使得子問題簡單又好算？各位讀者可以藉由本文的範例，體會分割問題的方式。</p>
<p class="t">範例：分解動作</p>
<p>想要學習「從中場帶球上籃」，我們可以將此動作分割為「跑步運球」、「跑步收球」、「單手將球放入籃框」等動作，分別學習。每一項動作都熟練之後，組合起來便是帶球上籃了。</p>
<p>如果覺得「跑步運球」還是太難，可以更細分成「原地運球」、「走動運球」、「運球時護球」等動作，克服了之後便能夠順利解決「跑步運球」的問題了。</p>
<img src="DivideAndConquer2.png">
<p class="t">範例：方格法求面積</p>
<p>左邊為原問題，右邊放大並細分的圖是其中一個子問題。</p>
<img src="DivideAndConquer3.png">
<p class="t">範例：分類數數</p>
<p>左邊最大的框框是原問題，將原問題的數字進行分類後再統計，分類後的每一個框框都是一個子問題。</p>
<img src="DivideAndConquer4.png">
<p class="e">UVa 11038</p>
<p class="t">Recursive Method</p>
<p>在分治法當中，亦得遞迴地分割問題，其實就是遞歸法。</p>
<img src="DivideAndConquer5.png">
<p>程式碼細分為三個階段：Divide、Conquer、Combine。Divide階段是把原問題分割成小問題，Conquer階段是解決小問題，Combine階段是運用小問題的解答，整理出原問題的解答。</p>
<img src="DivideAndConquer6.png">
<textarea>
divide_and_conquer(原問題)
{
	/* Divide */
	先將原問題分割成許多小問題;

	/* Conquer */
	遞迴呼叫函式，求得子問題的解;
	解答1 = divide_and_conquer(子問題1);
	解答2 = divide_and_conquer(子問題2);
	......

	/* Combine */
	用小問題的解答，算出原問題的解答;
	原問題解答 = 解答1 + 解答2 + ......;

	return 原問題解答;
}
</textarea>
<p class="e">UVa 620 10101 10144 10998</p>
<p class="t">範例：合併排序法（Merge Sort）</p>
<img src="DivideAndConquer7.png">
<p>Divide階段：資料分割成兩堆。</p>
<p>Conquer階段：兩堆資料各自從事Merge Sort。</p>
<p>Combine階段：兩堆已排序過的資料，合併成一堆。</p>
<p class="t">範例：快速排序法（Quicksort）</p>
<img src="DivideAndConquer8.png">
<p>Divide階段：選擇一個數值當作基準，把資料分割成左右兩堆，使得左堆數值小於基準，右堆數值大於基準，基準數值置於左右兩堆中間。</p>
<p>Conquer階段：左右兩堆資料各自從事Quicksort。</p>
<p>Combine階段：不做任何事。</p>
<p class="t">範例：不重複組合（Combination）</p>
<p>從N個人抓M個人出來組團，有哪些組合方式呢？</p>
<img src="DivideAndConquer9.png">
<p>N個人當中的其中一個人，叫做甲君好了，我們將原問題分割成兩種情形：甲君在團中、甲君不在團中。</p>
<pre>
甲君在團中，演變成剩下N-1個人要再抓M-1個人出來組團。
甲君不在團中，演變成剩下N-1個人仍要抓M個人出來組團。
</pre>
<p>綜合這兩個子問題的組合方式，就得到答案。</p>
<p class="t">範例：河內塔（Tower of Hanoi）</p>
<p>三根柱子、一疊盤子，盤子大小皆不同（盤子中間還得打個洞，這樣盤子才能穿在柱子上）。所有盤子都疊在第一根柱子，大的在下面，小的在上面。現在要將整疊盤子移到第三根柱子，並且保持原來的大小順序。每次只能搬動一個盤子到別根柱子，而且大的盤子一定要保持在小的盤子下面。</p>
<img src="DivideAndConquer10.png">
<p>想要移動最大的盤子到第三根柱子，必須先挪開上方整疊盤子到第二根柱子。移動上方整疊盤子，正好與原問題相同、而少了一個盤子，可以視作子問題。</p>
<img src="DivideAndConquer11.png">
<p>嘗試以此子問題解決原問題，解題過程因而簡化成三個步驟：一、上方整疊盤子移到第二根柱子；二、最大的盤子移到第三根柱子；三、方才的整疊盤子移到第三根柱子。</p>
<img src="DivideAndConquer12.png">
<textarea>
int p[5];	// 盤子所在的柱子。第i小的盤子放在第p[i]根柱子。

void move(int n, int t)	// 將前n小的盤子移到第t根柱子
{
	if (n == 0) return;
	move(n-1, 6-p[n]-t);
	cout << "從" << p[n] << "移到" << t;
	p[n] = t;
	move(n-1, t);
}

void tower_of_hanoi()
{
	// 五個盤子，都疊在第一根柱子。
	for (int i=1; i<=5; ++i) p[i] = 1;
	// 五個盤子，從第一根柱子移到第三根柱子。
	move(5, 3);
}
</textarea>
<p class="e">UVa 10017</p>
<p class="t">Prune and Search</p>
<p>「修剪搜尋法」是分治法的特例。去除不重要的子問題，只搜尋重要的子問題。</p>
<img src="DivideAndConquer13.png">
<p class="e">UVa 920</p>
<p class="t">範例：二分搜尋法（Binary Search）</p>
<img src="DivideAndConquer14.png">
<p>這是在已排序陣列裡面搜尋數值的方法。陣列由中央切成兩邊，一邊數字較小、一邊數字較大。這兩邊一定有一邊不是我們所要的，可以去除，只需要繼續尋找其中一邊。</p>
<p class="e">UVa 10077</p>
<p class="t">範例：尋找陣列裡第k大的數</p>
<img src="DivideAndConquer15.png">
<p>運用Quicksort的分割手法，把陣列切成兩邊，一邊數字較小、一邊數字較大。這兩邊一定有一邊不是我們所要的，可以去除，只需要繼續尋找其中一邊。</p>
<p class="t">範例：尋找假幣（Counterfeit Coin Problem）</p>
<p>一堆硬幣，當中一枚硬幣是假幣，重量比真幣輕，肉眼無法分辨差異。手邊的工具僅有一台天平，但沒有砝碼，該如何藉由天平判斷假幣？</p>
<p>當硬幣總數為一，那麼該幣就是假幣。當硬幣總數為二，則兩枚硬幣分別放在天平兩端秤重，較輕的一端就是假幣。當硬幣總數為三以上，一定有辦法找出假幣，以下介紹兩種策略。</p>
<p>採用遞增法。每次取兩枚硬幣，放在天平兩端秤重。當天平平衡，表示這兩枚硬幣都是真幣，接著繼續處理剩餘硬幣。當天平傾斜，比較輕的硬幣就是假幣。</p>
<img src="DivideAndConquer16.png">
<p>採用分治法。兩枚硬幣放在天平兩端秤重，當天平平衡，表示這兩枚硬幣都是真幣。接著只剩下N-2枚硬幣要尋找假幣──問題遞迴縮小了！</p>
<p>剩下N-2枚，太多了一點。一次取多一點硬幣，同時放在天平兩端秤，問題就能縮小更多了！</p>
<p>把所有硬幣平均分成三份，取兩份放在天平兩端秤重。當天平平衡，表示剩下的一份含有假幣，問題一次便縮小為1/3。當天平傾斜，表示比較輕的一份含有假幣，問題一次便縮小為1/3。</p>
<img src="DivideAndConquer17.png">
<p>讀者可以想想看：如果硬幣數量不是三的倍數怎麼辦？如果一開始不知道假幣與真幣孰輕孰重怎麼辦？</p>
<p class="e">UVa 12732 12733</p>
<p class="t">Marriage before Conquest</p>
<pre>
 Yu-Han 說道：
 2014/1/11 at 9:00
 
分享一下最近看到的技巧 – “marriage-before-conquest"
在做Divide and conquer中，遞迴求解的部份解答可以用來加速剩下的計算。

一個簡單的例子是
http://www.geeksforgeeks.org/sorted-linked-list-to-balanced-bst/
把已排序的單向鏈結串列轉成平衡的二元搜尋樹。

如果是用很直接的找中點然後分半遞迴求解，
時間複雜度是O(n lg n)，
但是實際上建立完左半邊的時候，就可以直接得到中點，
因此就可以使得時間複雜度降為O(n)。

一個稍困難的例子是，給定二維空間中的點集合S，
我們稱點p為S中的maxima，
如果在S中沒有任何點的x座標以及y座標同時都大於點p的x座標與y座標。
問題是要把所有maxima找出來。

基於Divide and conquer的技巧，利用x座標等分成兩半分別找出maxima，
然後把在子問題中是maxima但是在考慮整體時不是maxima的點刪除，
如此的時間複雜度可達到O(n lg n)。

使用marriage-before-coquest的技巧，
可以把時間複雜度降到O(n lg h)，h為maxima的個數。
方法是先計算右半邊的maxima，
然後利用右半邊的maxima把左半邊中不可能成為全體的maxima的點先刪除，
最後才計算左半邊。

同樣的技巧也可以用在convex hull上達到O(n lg h)的時間複雜度。

 Yu-Han 說道：
 2014/1/11 at 23:51

以convex hull為例子的話，
是prune-and-search和marriage before conquest的綜合應用。
當有了右半邊的convex hull的點，要刪除左半邊不可能為convex hull的點時，
需要使用線性規劃（利用prune-and-search），
或是自己設計一個prune-and-search的方法。
所以marriage before conquest和prune-and-search是不同的技巧。

除了這三個例子之外，我也找不太到其他marriage-before-conquest的範例了。
</pre>

</div></div><div class="a"><div class="h">
<p class="b">Dynamic Programming</p>
<p class="w">長江後浪催前浪，一替新人趲舊人。《張協狀元》</p>
</div><div class="c">
<p class="t">Dynamic Programming<br>= Divide and Conquer + Memoization</p>
<p>動態規劃是分治法的延伸。當遞迴分割出來的問題，一而再、再而三出現，就運用記憶法儲存這些問題的答案，避免重複求解，以空間換取時間。</p>
<p>動態規劃的過程，就是反覆地讀取數據、計算數據、儲存數據。</p>
<img src="DynamicProgramming1.png">
<p>動態規劃龐大複雜，詳細介紹請見專文「<a href="DynamicProgramming.html">Dynamic Programming</a>」。</p>

</div></div><div class="a"><div class="h">
<p class="b">Greedy Method</p>
<p class="w">今朝有酒今朝醉，明日愁來明日愁。《羅隱．自遣》</p>
<p class="w">博觀而約取，厚積而薄發。《蘇軾．稼說送張琥》　</p>
</div><div class="c">
<p class="t">Greedy Method</p>
<p>中文譯作「貪心法」，以Incremental Method或Iterative Method製造答案的方法，大致上分為兩類：</p>
<pre>
一、填答案：從沒有答案開始，逐步填滿答案。
二、改答案：先隨便弄個答案，逐步修飾答案。
</pre>
<pre>
一、觀察問題特徵，擬定一個填答案、改答案的原則。
二、隨便挑幾個特例，手算一下。
　　如果答案都對，就大膽假設此原則是正確的。
　　（也可以嘗試證明此原則必定正確。）
三、實作程式碼，把答案算出來。
</pre>
<p class="e">UVa 120 311 410 514 538 668 757 10148 10201 10249 10366 10382 10440 10602 10716 10718 10982 ICPC 3752 4788</p>
<p class="t">範例：找零錢</p>
<p>你去商店買東西，你掏出了一張一百元，買了一包23元的零食。店員須找零錢給你，但是你希望店員找給你的硬幣數目越少越好，如此口袋會輕一點。那麼店員會給你幾個硬幣呢？</p>
<img src="Greedy1.png">
<p>填答案的原則是：先找給你面額較高的硬幣。</p>
<p>金額越少，找給你的硬幣數目也就越少。先找給你面額較高的硬幣，金額下降的最多──如此一來，往後找給你的硬幣數目就一定是最少了。</p>
<p>注意到：當錢幣面額很特別時，這個方法才正確。詳情請參考「<a href="KnapsackProblem.html">Change-Making Problem</a>」。</p>
<p class="t">範例：文章換行（Word Wrap）</p>
<p>一大段的英文段落，適當的將文章換行，讓文字不超過紙張邊界，盡量節省紙張空間。</p>
<img src="Greedy2.png">
<p>填答案的原則是：字儘量往前擠，擠不下就換行。</p>
<p class="t">範例：騎士周遊問題（Knight's Tour）</p>
<p>西洋棋盤上，請找到一條路線，讓騎士恰好經過棋盤上每一格各一次。</p>
<img src="Greedy3.gif" width="204" height="204">
<p>填答案的原則是：走向出路選擇較少的格子。如果遇到出路選擇一樣多的格子，就走向位於下方的格子。如果又遇到一樣低的格子，就走向位於左方的格子。</p>
<img src="Greedy4.png">
<p>這種填答案的方式，耗盡死路，保留活路，將來走入死胡同的機會就變少了。有一種「置之死地而後生」的味道。</p>
<p>注意到：這個方法不一定會成功。我們根本無法證明這個方法會成功，只是乍看起來比較容易成功。</p>
<p>我們當下所做的最佳決定，以長遠的眼光來看，不一定是最佳決定。儘管貪心法不見得得到正確的、最好的答案，卻是個快速得到答案的好方法。</p>
<p class="t">範例：活動選擇問題（Activity Selection Problem）</p>
<p>暑假到了，有好多好多有趣的營隊可以參加囉！攀岩、潛水、單車環島團、吉他營、電腦營、……，每個營隊都好有趣，好想每個營隊都參加──可是卻有好多營隊的活動期間都互相卡到，沒辦法同時參加。到底要參加哪些營隊活動才好呢？當然是越多種越好！</p>
<img src="Greedy5.png">
<p>填答案的原則很簡單：優先選擇最早結束的活動，就能剩下最多時間來安排其他活動。</p>
<p>仔細分成兩種情況進行討論：一、最早結束的活動，與其他活動的時間不重疊；二、最早結束的活動，與某些活動的時間重疊。</p>
<p>一的狀況下，參加最早結束的活動，顯然是最理想的──憑空多參加了一個活動，又不耽誤到其他活動。</p>
<p>此觀念可以用Recursive Method詮釋：去除最早結束的活動、遞迴縮小問題。</p>
<img src="Greedy6.png">
<p>二的狀況下，最早結束的活動、以及時間與之重疊的活動當中，只能選擇其中一個參加。此時參加最早結束的活動，得以剩下比較多的時間，仍是最理想的。</p>
<p>此觀念可以用Recursive Method詮釋：去除最早結束的活動、去除因而無法參加的活動，遞迴縮小問題。</p>
<img src="Greedy7.png">
<p>填答案的原則是：所有活動按照結束時間排序，依序參加活動。如果時間允許就參加，如果時間衝突就不參加。</p>
<img src="Greedy8.png">
<p class="e">UVa 10020 ICPC 4328 5105</p>
<p class="t">範例：過橋問題（Bridge and Torch Problem）</p>
<p>月黑風高的夜晚，有一座不長不短的獨木橋，只能同時容兩人併行。</p>
<p>此時正好有四個寂寞難耐、悲苦淒涼，事實上是窮極無聊的四個人路經此地。他們手邊僅帶著一支手電筒，想要通過這危險的獨木橋。那橋下可是暗潮洶湧，一失足成千古恨，奔流到海不復回。</p>
<p>幸好四人閒閒沒事就常走這座橋，對路況簡直熟悉到不行，閉著眼睛走都可以，於是乎四人知道自己過橋分別需時1分鐘、2分鐘、5分鐘、10分鐘。但是不管他們的腳程不可思議的快、莫名其妙的慢，四人都是貪生怕死之徒，手上沒有握著手電筒的話，誰都不敢過橋；四人也都是視財如命之徒，就是誰也不想浪費錢，去附近的便利商店買支手電筒，寧可摔到水裡隨波逐流環遊世界去。</p>
<p>最後他們只好協議說，一次兩人同時持手電筒過橋，再請其中一人送回手電筒，沒事做的人就在橋邊哭爹喊娘等手電筒回來，如此一來四人最終都能夠順利過橋。</p>
<p>兩人同時過橋時必須配合走得慢的人的速度，請問全員過橋最快要多久時間？</p>
<p>有一些規矩你是知道的，例如不能把手電筒用丟的丟過河，不能四個人疊羅漢一起過橋，不能把橋拆了做木筏之類的。</p>
<img src="Greedy9.png">
<p>題目終於說完了，現在來談填答案的原則：</p>
<p>腳程快的人送手電筒回來那是最好的；相對地，腳程慢的人就應該讓他留在彼岸不要回來。不管先走後走，人人都還是要過橋，所以先試試看把腳程最慢的人送到對岸吧！</p>
<p>當人數眾多，至少四人時，令A與B是最快與次快，C與D是次慢與最慢。讓最慢的兩個人過橋主要有兩種方式，第一種是AB去A回、CD去B回，第二種是AD去A回、AC去A回，至於其它方式所花的時間恰好跟這兩種方式一樣。採用比較快的那一種方式，讓最慢的兩個人過橋之後，問題範疇就縮小了。</p>
<textarea>
// 各個人的腳程由慢到快排序
int a[8] = {1, 2, 5, 10, 15, 16, 30, 31};

void bridge_and_torch()
{
	int n, t = 0;
	for (n=8-1; n>=3; n-=2)
	{
		int t1 = a[0] + a[1]*2 + a[n];
		int t2 = a[0]*2 + a[n-1] + a[n];
		t += min(t1, t2);
	}

	if (n == 2) t += a[0] + a[1] + a[2];
	else if (n == 1) t += a[1];
	else t += a[0];

	cout << "所有人過橋的總時間為" << t;
}
</textarea>
<p class="e">UVa 10037</p>
<p class="t">範例：函數的區域最小值</p>
<img src="Greedy10.png">
<p>改答案的原則是：一開始x隨意設定一個數值，例如設定x = 0。微調x值，並且計算f(x)──如果f(x)減少，就更新x；如果f(x)沒減少，就不更新x。不斷修改x值，最後就到達區域最小值。</p>
<p class="t">範例：交換相鄰數字的排序法</p>
<img src="Greedy11.png">
<p>改答案的原則是：每當發現相鄰兩個數字，左邊數字大於右邊數字，兩個數字就交換位置。</p>
<p>不斷交換位置，導致大數字逐漸往右端移動、小數字逐漸往左端移動，最後一定能完成排序。</p>
<p>讀者可以想想看：交換任意兩個數字的排序法，成立嗎？</p>
<p>順帶一提，排序過程反向操作，可以得到一個結論：排序過的陣列，經由兩兩相鄰交換，一定可以得到各種排列方式。</p>
<p class="t">範例：荷蘭國旗問題（Dutch National Flag Problem）</p>
<p><a href="http://www.iis.sinica.edu.tw/~scm/ncs/2010/10/dutch-national-flag-problem/" class="l">http://www.iis.sinica.edu.tw/~scm/ncs/2010/10/dutch-national-flag-problem/</a></p>
<p><a href="http://www.iis.sinica.edu.tw/~scm/ncs/2010/10/dutch-national-flag-problem-2/" class="l">http://www.iis.sinica.edu.tw/~scm/ncs/2010/10/dutch-national-flag-problem-2/</a></p>
<p><a href="http://www.iis.sinica.edu.tw/~scm/ncs/2010/10/dutch-national-flag-problem-3/" class="l">http://www.iis.sinica.edu.tw/~scm/ncs/2010/10/dutch-national-flag-problem-3/</a></p>
<p class="t">範例：工作排程問題（Single Machine Scheduling, Minimize the Number of Tardy Jobs）（1||∑Ui）</p>
<p>有一位苦命上班族，要馬上處理臨時指派的N份工作。經驗老到的他，馬上就精準的估計出每份工作各要花掉多少時間，可是每份工作都有不同的完工期限，這造成有些工作可能會來不及完成。他做事專心，要求品質，一次只處理一份工作，一份一份接著做；來不及完成的工作，乾脆放棄不做。</p>
<p>請找出一種排程，讓如期完成的工作最多（也就是讓逾期完成的工作最少），順便讓總工時越短越好。</p>
<img src="Greedy12.png">
<p>合理排程之相鄰交換性質：</p>
<p>一個合理排程，其中某兩個如期完成的工作A與B，A與B緊鄰完成，A早做B晚做，A期限晚B期限早（或期限相同），則A與B對調位置之後，仍是一個合理排程。分析如下：</p>
<pre>
A與B視作一體進行交換：排程裡的其他工作皆不受影響。
A放到B的位置：A的期限比B還晚，B都能如期完成了，所以A也能如期完成。
B放到A的位置：B提早做，更能如期完成。
</pre>
<img src="Greedy13.png">
<p>一個合理排程，不斷地進行相鄰交換，終會形成「工作依照期限排序」的合理排程！反之亦然！小心，不相鄰則不可貿然交換。</p>
<p>因此，我們只需著眼於「工作依照期限排序」的合理排程。</p>
<p class="e">UVa 10026 11389</p>
<p>填答案的原則是：所有工作依照期限排序，依序加入排程。一次加入一個工作，一旦發現逾期，立即從排程當中抽掉工時最長的工作。</p>
<img src="Greedy14.png">
<pre>
已經加入N個工作，排程裡有M個工作。
排程裡的工作，是前N個工作的最佳解。也就是說：
α. 這M個工作，全部如期完成。
β. 前N個工作之中，如期完成的工作數量最多就是M。
γ. 前N個工作之中，這M個工作總工時最短。
</pre>
<p>以數學歸納法證明之。假設N成立，當第N+1個工作加入排程，有兩種情況。</p>
<p>一、沒有發生逾期：</p>
<p>這M個工作，本來就是如期完成、工作數量最多、總工時最短的最佳選擇。第N+1個工作加入之後，αβγ依然成立。</p>
<p>二、發生逾期，立即抽出工時最長的工作：</p>
<p>這M個工作，已經能如期完成。抽出工時最長的工作，補上工時稍短（或相等）的第N+1個工作，更能如期完成了。α成立。</p>
<p>這M個工作，總工時已經是最短了，還是無法添加第N+1個工作，不得已抽掉一個工作，工作數量已經盡量多了。β成立。</p>
<p>抽出工時最長的工作，總工時下降最多。γ成立。</p>
<textarea>
struct Job {int time, due;} job[10];
priority_queue<int> pq;

bool cmp(const Job& j1, const Job& j2)
{
	return j1.due < j2.due;
}

void Moore_Hodgson()
{
	sort(job, job+10, cmp);

	int t = 0;
	for (int i=0; i<10; ++i)
	{
		pq.push(job[i].time);
		t += job[i].time;
		if (t > job[i].due) t -= pq.top(), pq.pop();
	}

	cout << "如期完成的工作數量，最多為" << pq.size();
	cout << "逾期完成的工作數量，至少為" << 10 - pq.size();
}
</textarea>
<textarea>
struct Job
{
	int time, due;
	bool operator<(const Job& j) const
	{
		return due < j.due;
	}
} job[10];

int heap[10], size = 0;

void Moore_Hodgson()
{
	sort(t, t+10);

	int t = 0;
	for (int i=0; i<10; ++i)
	{
		heap[size++] = job[i].time;
		push_heap(heap, heap+size);
		t += job[i].time;

		if (t > job[i].due)
		{
			t -= heap[0];
			pop_heap(heap, heap+size);
			size--;
		}
	}

	cout << "如期完成的工作數量，最多為" << size;
	cout << "逾期完成的工作數量，至少為" << 10 - size;
}
</textarea>
<p class="e">UVa 10154 ICPC 3277 4850</p>
<p class="t">範例：工作排程問題（2-Machine Flowshop Scheduling）（F2||Cmax）</p>
<p>兩台機器，N份工作，一台機器一次只能處理一個工作。每份工作必須先經過初號機處理一段時間，再經過貳號機處理一段時間，才算處理完畢。</p>
<p>請找出一種排程，迅速完成所有工作。</p>
<img src="Greedy15.png">
<pre>
1. 建立兩個空的List，叫做L1和L2。
2. 從N個工作、2N個工時當中，不斷挑出工時最短的工作。
   如果最短工時是初號機的工時，該工作加到L1前端。
   如果最短工時是貳號機的工時，該工作加到L2後端。
3. L1 L2，即是排程。
</pre>
<pre>
1. 建立兩個空的List，叫做L1和L2。
2. 對每一個工作，若初號機工時小於貳號機工時，該工作加到L1，反之則加到L2。
3. L1照初號機工時由小到大排序。
   L2照貳號機工時由大到小排序。
4. L1 L2，即是排程。
</pre>
<textarea>
int c1[10];
int c2[10];

bool cmp1(const int& i, const int& j) {return c1[i] < c1[j];}
bool cmp2(const int& i, const int& j) {return c2[i] > c2[j];}

void Johnson()
{
	vector<int> l1, l2;
	for (int i=0; i<10; ++i)
		if (c1[i] < c2[i])
			l1.push_back(i);
		else
			l2.push_back(i);

	sort(l1.begin(), l1.end(), cmp1);
	sort(l2.begin(), l2.end(), cmp2);

	vector l = l1 + l2;
	int t1 = 0, t2 = 0;
	for (int i=0; i<l.size(); ++i)
	{
		t1 += c1[l[i]];
		t2 = max(t1, t2) + c2[l[i]];
	}
	cout << "總完成時間為" << t2 << endl;
}
</textarea>
<p class="e">UVa 11269 11729</p>
<p class="t">範例：平面上距離最近的兩個點（Closest Pair Problem）</p>
<p>採用遞增法，逐次增加一個點；採用窮舉法，計算新點到其他點的距離。每當發現更近的兩個點，下次即可減少橫向搜尋範圍。</p>
<p>運用目前得到的答案，藉此得到更好的答案！可以看作是間接地、改答案的原則。</p>
<img src="Greedy16.png">
<p>另外，還可以減少縱向搜尋範圍。除了新點以外，兩點之間的距離，至少都是上次的最短距離，不能太密太擠。在橫向搜尋範圍之內，進行縱向排序（採用即時排序的資料結構，效率較佳），只需檢查新點的上兩點、下兩點，就一定能檢查到半圓內所有點！</p>
<p>儘管無法直接得到正確的點，但是只需檢查少數幾點！可以看作是間接地、填答案的原則。</p>
<img src="Greedy17.png">
<p class="e">UVa 10245 ICPC 7581</p>

</div></div><div class="a"><div class="h">
<p class="b">Scaling Method</p>
<p class="w">古之欲明明德於天下者，先治其國。　　　　</p>
<p class="w">　　　　　欲治其國者，先齊其家。　　　　</p>
<p class="w">　　　　　欲齊其家者，先修其身。　　　　</p>
<p class="w">　　　　　欲修其身者，先正其心。《禮記》</p>
</div><div class="c">
<p class="t">Fixed Parameter Method</p>
<p>「固定參數法」。當問題太過困難，就增加限制，將部分變數改成常數。</p>
<p class="t">範例：三維函數繪圖</p>
<p>一、固定X值，計算Y值Z值；嘗試各種X值。</p>
<p>二、固定Y值，計算X值Z值；嘗試各種Y值。</p>
<p>三、固定Z值，計算X值Y值；嘗試各種Z值。</p>
<a href="http://stackoverflow.com/questions/1526898/"><img src="FixedParameter1.gif"></a>
<p class="t">Scaling Method</p>
<p>「縮放法」。將數值拆解為不同數量級，每個數量級分別計算一次答案，並且累計每次計算成果。</p>
<p class="t">範例：乘法</p>
<p>數量級從小到大：乘數拆解為不同數量級，先以個位數相乘一次，再以十位數相乘一次，……，再以最高位數相乘一次，累加起來，得到正確結果。</p>
<img src="Scaling1.png">
<p class="t">範例：基數排序法（Radix Sort）</p>
<p>數量級從小到大：所有數字先以個位數排序一次，再以十位數排序一次，……，再以最高位數排序一次，得到正確結果。</p>
<img src="Scaling2.png">
<p>數量級從大到小：所有數字先以最高位數排序一次，再以前兩高位數排序一次，……，再以全部位數排序一次，得到正確結果。</p>
<img src="Scaling3.png">
<p>改善計數排序法的效率，不必建立一長串陣列。</p>
<p class="t">範例：多重解析度匹配（Multiscale Matching）</p>
<p>從宏觀到微觀，從粗糙到細膩。短字串跳N格實施匹配。若足夠相似，才跳N/2格實施匹配。……。若足夠相似，才跳1格實施匹配。</p>
<img src="Scaling4.png">
<p>改善匹配的效率，不必每次都比對一大串字元。</p>
<p class="t">範例：Shell排序法（Shell Sort）</p>
<p>從宏觀到微觀，從粗糙到細膩。跳N個數字為同一組，每組分別實施插入排序法。跳N/2個數字為同一組，各組分別實施插入排序法。……。跳1個數字為同一組，所有數字實施插入排序法。</p>
<img src="Scaling5.png">
<p>改善插入排序法的效率，不必每次都挪動一大串數字。</p>

</div></div><div class="a"><div class="h">
<p class="b">External Memory Algorithm（Under Construction!）</p>
<p class="w">士農工商四民者，國之石，民也。　　　　　　</p>
<p class="w">不可使雜處，雜處則其言哤，其事亂。《管子》</p>
</div><div class="c">
<p class="t">Streaming Algorithm</p>
<p class="t">範例：緩衝區（Buffer）</p>
<p class="t">範例：選擇排序法暨二分搜尋法（Selection Sort + Binary Search）</p>
<p>檔案太大，記憶體不足，只好屢次從檔案裡面取得一部分數字。由於沒有其他暫存區，只好取得最小的數字，即時輸出結果。</p>
<p>篩選最小的數字、排序、輸出。活用二分搜尋法，調控篩選範圍，符合記憶體容量。</p>
<p>小心處理同一數字數量非常多的情況。</p>
<textarea>
int MIN = -1000000000;	// 數字的最小值
int MAX = 1000000000;	// 數字的最大值
const int N = (1 << 19);
const int M = (1 << 18);
int memory[N];			// 記憶體（內存）
int buffer[M];			// 緩衝區（緩存）

// 讀取檔案裡面所有數字，篩選大於等於L、小於等於R的數字。
int read(ifstream& fin, int L, int R)
{
	int n = 0;
	fin.clear();			// 回復讀寫狀態
	fin.seekg(0, fin.beg);	// 回到檔案開頭

	while (true)
	{
		// 讀取檔案裡面的數字
		fin.read((char*)buffer, sizeof(int)*M);
		int c = fin.gcount() / sizeof(int);
		if (c <= 0) break;	// 沒有數字就結束

		// 篩選數字，儲存至記憶體。
		for (int i = 0; i < c; i++)
			if (buffer[i] >= L && buffer[i] <= R)
				if (L == R)
				{
					if (n < N) memory[n++] = buffer[i];
					else n++;	// 同一數字出現許多次
				}
				else
				{
					if (n < N) memory[n++] = buffer[i];
					else return -1;	// 存不下
				}
	}
	return n;
}

// 選擇排序法
// 屢次從檔案裡面篩選最小的數字們。排序。輸出。
// 如果記憶體裝不下，把數值範圍變一半，重做一遍。
void sort_file()
{
	ifstream fin("number.in", ios::binary);
	ofstream fout("number.out", ios::binary);

	// 二分搜尋法
	for (int L = MIN, R = MAX; L <= R; )
	{
		int M = (L + R) / 2;
		int n = read(fin, L, M);

		if (n < 0)			// 記憶體不足。縮小篩選範圍。
			R = M;
		else if (n == 0)	// 處理其餘範圍
			L = M + 1;
		else				// 記憶體充足。排序。輸出。
		{
			if (L == M)
			{
				for ( ; n > N; n -= N)
					fout.write((char*)memory, sizeof(int)*N);
				if (n > 0)
					fout.write((char*)memory, sizeof(int)*n);
			}
			else
			{
				sort(memory, memory + n);
				fout.write((char*)memory, sizeof(int)*n);
			}

			// 處理其餘範圍
			L = M + 1;
			R = MAX;
		}
	}

	fin.close();
	fout.close();
}
</textarea>
<p class="t">範例：動態陣列（Vector）</p>
<p class="t">Cache-oblivious Algorithm</p>
<p>儲存容量大，存取時間長；儲存容量小，存取時間短。魚與熊掌不可兼得。自然而然形成階層式架構：硬碟、記憶體、快取、暫存器，儲存容量越來越小，存取時間越來越短。</p>
<p>進行計算的變數，儲存在暫存器；暫存器沒有，就找快取；快取沒有，就找記憶體；記憶體沒有，就找硬碟。</p>
<pre>
cpu cache   256KB
main memory 512MB - 1024MB
disk        20GB - 120GB
</pre>
<img src="Cache-oblivious1.png">
<p>對中央處理器來說，最花時間的不是運算，而是從記憶體載入資料到快取。調整資料結構、調整計算順序，避免頻繁載入資料。</p>
<p class="t">範例：陣列與串列</p>
<p>陣列在記憶體是連續的。串列在記憶體通常不是連續的。</p>
<p>循序枚舉，陣列偶爾載入區塊，串列時常載入區塊。</p>
<img src="Cache-oblivious2.png">
<p class="t">範例：生命遊戲</p>
<p>區塊循序銜接成為一維陣列。一維陣列循序銜接成為二維陣列。</p>
<img src="Cache-oblivious3.png">
<p>生命遊戲有數個回合，一個回合枚舉每個位置，一個位置枚舉八個方向。上下方向通常是不同區塊，左右方向通常是相同區塊。</p>
<p>區塊從長條改成方塊，減少載入次數。</p>
<img src="Cache-oblivious4.png">
<p class="t">External Memory Algorithm</p>
<p>快取的儲存容量不敷使用，必須在快取與記憶體之間來回搬移資料，不得不浪費大量時間。</p>
<p>「外部記憶體演算法」是假設輸入資料放在外部記憶體（例如硬碟、光碟、隨身碟），必須從外部記憶體讀取資料至快取，將通道大小、快取大小納入考慮的演算法。</p>
<p>「快取無視演算法」採用相同假設，而通道大小、快取大小為定值，僅考慮存取次數。這也是將記憶體架構納入考慮的演算法，雖然名稱上完全不是那麼回事。</p>
<p class="t">範例：合併排序法（Merge Sort）</p>
<p>如果必須直接輸出答案，每次都要讀檔掃描所有數字，抓出最小的那些數字。</p>
<p>如果有檔案可以暫存計算結果，考慮存取次數。</p>
<p>讀取 n/ram size + n/input buffer size + n/output buffer size 次。</p>
<p>ram size = input buffer size * k + output buffer size</p>
<p class="t">範例：桶子排序法（Bucket Sort）</p>
<p>http://stackoverflow.com/questions/7153659/</p>

</div></div><div class="a"><div class="h">
<p class="b">Parallel Algorithm（Under Construction!）</p>
<p class="w">眾心成城，眾口鑠金。《國語》</p>
</div><div class="c">
<p class="t">Parallel Algorithm</p>
<p>「循序計算Sequential Computing」就是逐一計算，「平行計算Parallel Computing」就是一齊計算，兩者是相對的概念。</p>
<p>「平行化」。當計算順序無所謂時，就可以使用多個計算器一齊計算。優點是減少計算時間，缺點是增加硬體、增加電力。</p>
<img src="Parallel1.png">
<p>詳細架構是：一份記憶體，多個計算器。一份記憶體一齊傳遞資料給各個計算器，多個計算器一齊計算，多個計算器一齊傳遞資料給一份記憶體。</p>
<p>計算器又有兩種類型：多個計算器只能一齊執行相同指令（例如GPU），多個計算器可以分頭執行不同指令（例如多核心處理器）。前者富含巧思，後者缺乏變化，所以我們只談前者。</p>
<img src="Parallel2.png">
<p class="t">範例：複製字串</p>
<p>理論：各個字元分頭複製，時間複雜度從O(N)變O(1)。</p>
<img src="Parallel2.png">
<p>實務：字串切成數段，分頭複製。</p>
<img src="Parallel3.png">
<textarea>
void copy()
{
	char s[15] = "incremental";
	char t[15];

	int i;
	#pragma omp parallel for
	for (i=0; s[i]; ++i)
		t[i] = s[i];
	t[i] = '\0';

	cout << "原本字串" << s;
	cout << "複製之後的字串" << t;
}
</textarea>
<p>因為作業系統建立執行緒需要大量時間與空間，所以平行計算不一定比循序計算好。程式員必須自行取捨。</p>
<p class="t">範例：加總數字</p>
<p>理論：數字雙雙相加，時間複雜度從O(N)變O(logN)。</p>
<img src="Parallel3.png">
<p>實務：陣列切成數段，分頭計算總和。最後累加各段總和。</p>
<img src="Parallel4.png">
<textarea>
void summation()
{
	int array[5] = {3, 6, 9, -8, 1};

	// 陣列切成兩段，分頭計算總和。
	int sum = 0;
	#pragma omp parallel for num_thread(2) schedule(static) reduction(+:sum)
	for (int i=0; i<5; i++)
		sum = sum + array[i];

	cout << "總和是" << sum;
}
</textarea>
<p class="t">範例：矩陣相乘</p>
<p>理論：兩層的平行化，外層是乘積矩陣的每一個元素，內層是兩串數列點對點相乘，時間複雜度從O(N^3)變O(1)。</p>
<p>實務：執行緒數量高達O(N^3)，不但跟循序計算沒兩樣，而且還得額外浪費設置執行緒的時間與空間，弄巧成拙、過猶不及。大家習慣放棄數列相乘的平行化。</p>
<img src="Parallel5.png">
<textarea>
void matrix_multiply(float A[N*N], float B[N*N], float C[N*N])
{
	int i, j, k;
	#pragma omp parallel for collapse(2) private(k)
	for (i=0; i<N; i++)
		for (j=0; j<N; j++) 
		{
			// 放棄數列相乘的平行化
			for (k=0; k<N; k++)
				C[N*i+j] += A[N*i+k] * B[N*k+j];
		}
}
</textarea>
<p>相同資料重複傳遞很多份到各個執行緒，改為每次計算一塊區域。</p>
<img src="Parallel6.png">
<textarea>
const int int N, P, M;	// matrix dimensions
float A[N*P], B[P*M], C[N*M];
int NB = 0;				// number of blocks
int Nb = N / NB;		// block dimensions
int Pb = P / NB;
int Mb = M / NB;

void clear_block(float* C, int gapC, int Nb, int Mb)
{
	for (int i=0; i<Nb; ++i) 
		for (int j=0; j<Mb; ++j)
			// C[i][j] = 0;
			C[i * gapC + j] = 0.0;
}

void multiply_block(float* A, float* B, float* C, int gapA, int gapB, int gapC)
{
	for (int i=0; i<N; ++i)
		for (int j=0; j<M; ++j)
		{
			// C[i][j] += A[i][k] * B[k][j];
			float t = C[i*gapC + j];
			for (int k=0; k< P; ++k)
				t += A[i*gapA + k] * B[k*gapB + j];
			C[i*gapC + j] = t;
		}
}

void matrix_multiply()
{
	int ib, jb, kb;
	#pragma omp parallel for private(jb,kb) schedule(static)
	for (ib=0; ib<NB; ++ib)
		for (jb=0; jb<NB; ++jb)
		{
			// Cb[ib][jb] = 0;
			float* ptrC = C + ib * Nb * M + jb * Mb;
			clear_block(ptrC, M, Nb, Mb);

			// Cb[ib][jb] = Ab[ib][kb] * Bb[kb][jb];
			for (kb=0; kb<NB; ++kb)
				multiply_block(
					A + ib * Nb * P + kb * Pb,
					B + kb * Pb * M + jb * Mb,
					ptrC,
					P, M, M
				);
		}
}
</textarea>
<p class="t">範例：生命遊戲</p>
<p>理論：兩層的平行化，外層是地圖的每一個細胞，內層是八個鄰居細胞數量總和，時間複雜度從O(XY * 8)變O(log8)。</p>
<p>實務：大家習慣放棄放棄平行化細胞求和。</p>
<img src="Parallel7.png">
<p class="t">範例：Hamilton Path</p>
<p>理論：如果能夠建立N!個執行緒，時間複雜度就從O(N!)變O(N)──可是要去哪裡生那麼多個執行緒？即便是平行化也無法快速解決NP-Complete問題。</p>
<img src="Parallel8.png">
<p class="t">範例：branch overhead</p>
<p class="t">Distributed Algorithm</p>
<p>Parallel Algorithm和External Memory Algorithm合體之後的東西。</p>
<p>https://paper.dropbox.com/doc/Google-DCJ--MnMwtOSSmcM4ZaEzFOpNF</p>

</div></div><div class="a"><div class="h">
<p class="b">Randomized Algorithm（Under Construction!）</p>
<p class="w">有過物者必濟，故受之以既濟。《序卦》</p>
<p class="w">致中和，天地位焉，萬物育焉。《禮記》</p>
</div><div class="c">
<p class="t">Randomization</p>
<p>主要有三種類型：</p>
<p>一、當計算順序無所謂時──此時可以隨機挑選其中一種計算順序。</p>
<p>二、當我們不清楚輸入資料的分布情況，無從分析average case的時間複雜度──此時可以套用隨機化，將時間複雜度的期望值，姑且當作是average case的時間複雜度。</p>
<p>三、當我們十分清楚輸入資料的分布情況、而且輸入資料接近worst case──此時可以運用隨機化破壞worst case，有很大機率能趨吉避凶，減少計算時間；但是也有一定機率會弄巧成拙，增加計算時間。</p>
<p>套用隨機化之後，必須運用機率來分析時間複雜度。一種計算順序，對應一個時間複雜度；考慮每一種計算順序的出現機率，求得時間複雜度的期望值（平均值）。</p>
<p class="t">範例：交換相鄰數字的排序法</p>
<p class="t">範例：快速排序法（Quicksort）</p>
<p>無論挑選哪一個陣列元素作為pivot，最後都能得到正確的排序結果。</p>
<p>遞迴的時候，對半分是最好的，遞迴深度最少，遞迴次數也最少。也就是說，選擇「排序之後位於中央」的陣列元素作為pivot是最理想的。</p>
<p>因此，實務上最好的方式其實不是隨機選取pivot；而是將陣列切三份、取三個中央值的中位數作為pivot。因為上一層的partition步驟當中，陣列已經大略排序好了，所以這種方式更有機會得到「排序之後位於中央」的陣列元素。</p>
<p class="t">範例：隨機搜尋</p>
<p>隨便搜尋其中一筆資料。如果失敗，就縮小搜尋範圍，從剩下的位置，再隨便搜尋其中一筆資料。</p>
<p>為了讓演算法能夠結束，我們一定要逐步縮小搜尋範圍。已經搜尋過的資料，千萬不要再重複搜尋了。</p>
<textarea>
int array[5] = {3, 5, 6, -2, 1};
int visit[5];

int random_search(int n)
{
	for (int i=0; i<5; i++)
		visit[i] = false;

	// 錯誤的實作方式。
	// 程式可能永不結束，儘管機率趨近無限小。
	srand(time(0));
	for (int k=0; k<5: k++)
	{
		int i;
		do i = rand() % k; while (visit[i]);
		if (array[i] == n) return i;
		visit[i] = true;
	}
	return -1;
}
</textarea>
<textarea>
int array[5] = {3, 5, 6, -2, 1};
int index[5];

int random_search(int n)
{
	srand(time(0));
	for (int k=5; k>0; k--)
	{
		// 已經找過的資料，就挪到最後、永不再找。
		int i = rand() % (5 - k);
		if (array[i] == n) return i;
		swap(array[i], array[5 - k - 1]);
	}
	return -1;
}
</textarea>
<p>這裡再額外補充一個實作方式。</p>
<p>仔細觀察計算過程。一個步驟恰好讀取了一筆資料，所有步驟恰好讀取了每一筆資料──綜觀整個計算過程，其實是以隨機的順序，讀取了每一筆資料。</p>
<p>因此，在此範例當中，隨機的計算順序，恰好可以改成隨機的輸入順序。實作時，預先隨機排列輸入資料，然後循序搜尋。</p>
<textarea>
int array[5] = {3, 5, 6, -2, 1};

int random_search(int n)
{
	// 隨機排列 random permutation
	random_shuffle(array, array+5);

	// 循序搜尋 sequential search
	for (int i=0; i<5; ++i)
		if (array[i] == n)
			return i;
	return -1;
}
</textarea>
<textarea>
int array[5] = {3, 5, 6, -2, 1};
int index[5];

int random_search(int n)
{
	// 隨機排列索引值或者指標，
	// 就不必搬動原本的輸入資料。
	for (int i=0; i<5; ++i) index[i] = i;
	random_shuffle(index, index+5);

	for (int i=0; i<5: ++i)
		if (array[index[i]] == n)
			return index[i];
	return -1;
}
</textarea>
<p>搜尋次數的期望值是(N+1)/2。N是資料數量。</p>
<pre>
尚待搜尋的資料，在每個位置的出現機率都一樣多，都是1/N。
資料出現在第一個位置，從頭開始讀入一筆資料就能找到。
資料出現在第N個位置，從頭開始讀入N筆資料才能找到。
  (1/N) * 1 + (1/N) * 2 + ... + (1/N) * N
= (1/N) * (1+...+N)
= (1/N) * (1+N)*N/2
= (1+N)/2
</pre>
<p class="t">範例：隨機排序</p>
<p>從陣列當中隨便挑兩個數字，如果左邊數字大於右邊數字就交換位置。不斷交換位置，直到排序成功。</p>
<p>仔細來說，每一次想要交換兩個數字，一開始有N*(N-1)種數對可供選擇，隨便挑一個數對並且嘗試交換位置。如果無法交換位置，就從剩下的數對當中，再隨便挑一個數對，直到可以交換位置為止。如果所有數對都試過了，依然無法交換位置，就表示排序成功了。</p>
<p>我不知道如何分析時間複雜度，也不知道如何實作。</p>

</div></div><div class="a"><div class="h">
<p class="b">Simulation</p>
<p class="w">陽春召我以煙景，大塊假我以文章。《李白．春夜宴桃李園序》</p>
</div><div class="c">
<p class="t">Simulation</p>
<p>撰寫程式，模擬行為。</p>
<p class="e">UVa 10550</p>
<p class="t">範例：踩地雷</p>
<p>試著用程式模擬踩地雷吧！</p>
<img src="Simulation1.png">
<p class="e">UVa 10189 10279 11142 ICPC 4335</p>
<p class="t">範例：撲克牌</p>
<p>試著用程式模擬各種撲克牌遊戲吧！</p>
<img src="Simulation2.png">
<p><a href="http://mathworld.wolfram.com/Cards.html">http://mathworld.wolfram.com/Cards.html</a></p>
<p><a href="http://mathworld.wolfram.com/topics/CardGames.html">http://mathworld.wolfram.com/topics/CardGames.html</a></p>
<p class="e">UVa 127 131 162 170 178 181 451 462 555</p>
<p class="t">範例：下棋</p>
<p>使用棋盤進行遊戲，例如象旗、西洋棋、將旗、圍棋、五子棋、黑白棋。考慮人工智慧之前，先來模擬下棋規則，設計一支下棋程式吧！</p>
<img src="Simulation3.png">
<p class="e">UVa 220 852 10196 10363 10996 11210 1589</p>
<p class="t">範例：轉骰子</p>
<p>有兩顆骰子，上面的點數順序，可能是亂的、重複的。請辨別兩顆骰子一不一樣。骰子經過旋轉後，如果六個對應的面，上面的點數皆相同，則骰子視為相同。</p>
<p>要辨別兩顆骰子一不一樣，一種方式是旋轉其中一顆骰子，再跟另一顆比對。必須將骰子所有可能的情形都轉出來才行。</p>
<img src="Simulation5.png">
<p>骰子一共有六個面：上下前後左右。建立六個變數、或者六格的陣列，分別儲存六個面的點數。陣列的第0格存入上面的點數、第1格存左面的點數、……。當然也可以採用不同的儲存方法。</p>
<p>骰子一共有三種旋轉方向：東西方向、南北方向、時鐘方向。我個人偏好的轉法是：東西方向轉一圈，順時針方向轉一圈，南北方向轉一下，以上動作重複四次，就能轉出所有情形。</p>
<p>亦得採用其他轉法，最好的轉法只需轉24次，讀者可以想想看怎麼做。</p>
<p>亦得預先計算所有旋轉結果，儲存於lookup table，以節省旋轉時間。</p>
<textarea>
// 往西轉一下
void turn_west(int dice[6])
{
	int temp = dice[1];
	dice[1] = dice[2];
	dice[2] = dice[3];
	dice[3] = dice[4];
	dice[4] = temp;
}

// 六個面是否一一對應
bool equal(int a[6], int b[6])
{
	for (int i=0; i<6; i++)
		if (a[i] != b[i])
			return false;
	return true;
}

// 兩顆骰子是否相同
bool check(int a[6], int b[6])
{
	for (int i=0; i<4; i++)
	{
		for (int j=0; j<4; j++)
		{
			turn_west();
			if (equal(a,b)) return true;
		}

		for (int j=0; j<4; j++)
		{
			turn_clockwise();
			if (equal(a,b)) return true;
		}

		turn_north();
		if (equal(a,b)) return true;
	}
	return false;
}
</textarea>
<p class="e">UVa 253 10877</p>

</div></div><div class="a"><div class="h">
<p class="b">Modeling</p>
<p class="w">前事不忘，後事之師。《戰國策》</p>
</div><div class="c">
<p class="t">Modeling</p>
<p>把問題對應到耳熟能詳的模型，套用既有模型解決新問題。</p>
<p class="t">範例：平行四邊形面積</p>
<p>小學數學老師教過：長方形的面積是「長乘寬」。儘管不知道原因，不過這個公式肯定是正確的。那麼，請問平行四邊形面積如何計算？</p>
<img src="Modeling1.png">
<p>把平行四邊形凸出的三角形切下來，補在另一邊，平行四邊形就變成了長方形。想要計算平行四邊形面積，可以直接套用長方形面積公式。</p>
<p>平行四邊形的底，就是長方形的長；平行四邊形的高，就是長方形的寬。平行四邊形的元件，一一對應到長方形。</p>
<p class="t">範例：約瑟夫問題（Josephus Problem）</p>
<p>8個人圍成一圈，現在從第一個人開始報數，數到第5人時，就殺死這第5人；然後從被殺的下一位繼續重新報數，數到第5人時，就殺死這第5人。如此不斷數5人、殺此人，直到最後會剩下一個人，請問他是誰？</p>
<img src="Modeling2.png">
<p>數人和殺人的動作可以對應到佇列（queue）的操作。首先把每個人依序放進佇列，接著連續pop和push 4人，接著pop第5人時，不要將他放回佇列裡面即可！</p>
<img src="Modeling3.png">
<p class="t">範例：用圖論作為模型，模擬小畫家倒墨水。</p>
<p>圖論的觀點之下，Flood Fill Algorithm其實就是運用Depth-first Search找到Connected Component。</p>
<img src="Modeling4.png">
<p class="t">範例：用生命遊戲作為模型，模擬生命遊戲。</p>
<iframe src="http://www.youtube.com/embed/QtJ77qsLrpw"></iframe>
<p class="t">範例：System of Difference Constraints in Linear Programming</p>
<img src="SystemOfDifferenceConstraints.png">
<p>問題：給定變數x1到xN，並給定一些xi-xj≤c的式子，作為條件限制。請判斷有沒有解，如果有解就求出其中一組解。</p>
<p>這個問題可以巧妙的轉換成最短路徑問題。x1到xN看作是圖上的N個點，一條xi-xj≤c的限制式子看作是一條xj到xi的邊，其權重是c。</p>
<p>如果無解，那麼圖上有負環。如果有解，那麼圖上各點的最短路徑長度就是其中一組解。為了讓圖上各點都有最短路徑長度值，可參考Johnson's Algorithm的做法。</p>
<p class="e">UVa 515 ICPC 2058</p>
<p class="t">範例：Sentiment Relation in Social Balance Theory</p>
<p>從前有一位心理學者認為，人與人之間的關係，可以粗略分為兩種：互相喜歡、互相討厭。這種關係稱作Sentiment Relation，是一種雙向關係，而且擁有喜歡與討厭兩種類型。假使兩人之間好惡分明，沒有亦敵亦友的情況，就會形成Sentiment Relation。</p>
<pre>
   like            hate
A<------>B      A<------>B
</pre>
<p>另外Sentiment Relation還具有相當特殊的性質，有點像是transitivity、symmetry、antisymmetry的總合。這種性質的最佳寫照，諸如同仇敵愾、合縱連橫等等，翻成白話就是這樣：</p>
<pre>
1. 朋友的朋友就是我的朋友。
2. 朋友的敵人就是我的敵人。
3. 敵人的朋友就是我的敵人。
4. 敵人的敵人就是我的朋友。
</pre>
<p>在Sentiment Relation所形成的社交結構當中，如果產生了好與惡的矛盾，那麼這樣的社交結構就是不平衡的；如果好與惡合理，那麼這樣的社交結構就是平衡的。心理學者相信，當社交結構不平衡的時候，個體會嘗試改變自己的觀點，讓社交結構趨向平衡。</p>
<pre>
balance:

      A                A           like   like
like / \ like    hate / \ hate      ----A----
    /   \            /   \         /  ha|te  \
   B-----C          B-----C       B-----C-----D
     like             like         hate   hate
 
imbalance:

      A                A           like   like
hate / \ hate    like / \ like      ----A----
    /   \            /   \         /  ha|te  \
   B-----C          B-----C       B-----C-----D
     hate             hate         like   like
</pre>
<p>後來心理學者進一步發現，當社交結構達到平衡，所有人可以分成兩大陣營，使得陣營內部的關係都是互相喜歡，陣營與陣營之間的關係都是互相討厭。</p>
<img src="SentimentRelation1.png">
<p>說了這麼多終於要提到重點。現在問題來了，假設社交結構是平衡的，而我們也知道一些兩兩相互喜歡、相互討厭的資訊時，我們該如何確認誰在同一陣營、誰在不同陣營呢？</p>
<p>一、以Bipartite Graph作為模型：</p>
<p>把社交結構看作是Bipartite Graph，Bipartite Graph的兩側分別是兩大陣營。首先利用Graph Traversal走訪喜歡的邊，找出所有連通分量，並各自縮成一點。然後再度利用Graph Traversal走訪討厭的邊，嘗試建立Bipartite Graph，如果無法建立則表示社交結構不平衡。</p>
<p>二、以聯集為基礎來建立新模型：</p>
<pre>
當x與y是朋友：
　x及朋友、y及朋友，都是好朋友。
　x的敵人、y的敵人，都是好朋友。

當x與y是敵人：
　x及朋友、y的敵人，都是好朋友。
　x的敵人、y及朋友，都是好朋友。
</pre>
<p>用Disjoint Sets的union，把好朋友們聯集在一起。要判斷同一陣營，就看看大家是不是同一群好朋友；要判斷不同陣營，就看看對方的敵人是不是跟自己是同一群好朋友。由於一開始每個人都沒有敵人，所以替每個人都設定一個虛擬的假想敵。</p>
<textarea>
#define _x (x + 100)	// x的假想敵
#define _y (y + 100)	// y的假想敵

// Disjoint-sets Forest
int p[100 + 100];		// 前百人為本尊，後百人為假想敵。
int init() {for (int i=0; i<200; ++i) p[i] = i;}
int find(int x) {return x == p[x] ? x : (p[x] = find(p[x]));}
void union(int x, int y) {p[find(x)] = find(y);}

bool if_like(int x, int y)
{
	return find(x) == find(y);
//	return find(_x) == find(_y);
}

bool if_hate(int x, int y)
{
	return find(x) == find(_y);
//	return find(_x) == find(y);
}

// 結交朋友
void like(int x, int y)
{
	if (if_hate(x, y)) return;	// imbalance
	union(x, y);
	union(_x, _y);
}

// 樹立敵人
void hate(int x, int y)
{
	if (if_like(x, y)) return;	// imbalance
	union(x, _y);
	union(_x, y);
}
</textarea>
<p class="e">UVa 10158 10505 10608</p>
<p class="t">Reduction</p>
<p>套用模型當中，有一種情況是：原問題是某一個問題的特例。套用通例，解決特例，稱作「歸約」。</p>
<p>因為通例相對複雜、特例相對單純，所以原問題極可能存在更快更好的解法。</p>
<p class="t">範例：最短間距（Minimum Gap Problem）</p>
<p>一條鐵道，沿途設站。已知里程，請找出距離最近的兩站。</p>
<img src="Modeling5.png">
<p>以數線作為模型，鐵道對應到數線、車站對應到點座標，距離最近的兩站對應到「數線上距離最近的兩個點」。</p>
<p>想要解決「數線上距離最近的兩個點」，可以套用先前介紹的「平面上距離最近的兩個點」。這兩個問題的本質是相同的，前者是一維版本，後者是二維版本；前者是特例，後者是通例。</p>
<p>只要把每個車站的座標，增加一個維度，該維度的數值通通設定為相同數值，然後計算「平面上距離最近的兩個點」，就得到距離最近的兩站。</p>
<p>「數線上距離最近的兩個點」是特例、「平面上距離最近的兩個點」是通例，我們有機會替「數線上距離最近的兩個點」找到計算時間更短、更有效率的演算法。</p>
</div></div><script src="h.js"></script></body></html>